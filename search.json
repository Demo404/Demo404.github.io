[{"title":"MySQL学习 ｜ 一、MySQL的基本概念和安装","url":"/2023/07/26/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E4%B8%80%E3%80%81MySQL%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%89%E8%A3%85/","content":"一、数据库相关的概念数据库（DB）：存储数据的仓库，数据是有组织的进行存储。\n数据库管理系统（DBMS）：操作和管理数据库的大型软件。‍‍‍‍‍‍‍\nSQL：操作关系型数据库的编程语言，定义了一套操作关系型数据库的统一标准。  \n​\t\t  \n二、主流的数据库管理系统1、Oracle：oracle公司研发，大型且收费。\n2、MySQL：小型，有免费有收费。‍\n3、PostgreSQL：中小型数据库，免费。\n4、SQLite：嵌入性数据库，安卓系统采用SQLite。\n. . . . . .‍‍‍\n​\t\t\n三、MySQL的安装和启动‍‍‍版本：\n社区版（MySQL Community Server）\n免费，MySQL不提供任何技术支持。\n\n商业版（MySQL Enterprise Edition）‍‍\n收费，可试用，MySQL提供技术支持。\n\n\n下载地址：https://dev.mysql.com/downloads/ 或者 https://www.mysql.com/ 依次如下点击进行下载。\n\n下拉页面找到download\n\n下载 MySQL Community Server 版（根据自身情况选择）\n\n然后选择对应的版本下载\n\n最后一步可以不用登录和注册。\n\n安装步骤：1、上传下载的安装包到服务器的 &#x2F;usr&#x2F;local 目录下‍\n2、使用 tar 命令解压下载的安装包‍\n tar -xvf mysql-8.0.33-linux-glibc2.12-x86_64.tar.xz参数说明：-x：解压缩压缩档案的参数-v：压缩的过程中显示档案-f：置顶文档名，在f后面立即接文件名，不能再加参数\n\n3、重命名解压后的文件夹\nmv mysql-8.0.33-linux-glibc2.12-x86_64 mysql\n\n4、修改MySQL的配置文件如下\nvim /etc/my.cnf\n# For advice on how to change settings please see# http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html[mysqld]skip-name-resolvecharacter_set_server=utf8init_connect=&#x27;SET NAMES utf8&#x27;## Remove leading # and set to the amount of RAM for the most important data# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.# innodb_buffer_pool_size = 128M## Remove leading # to turn on a very important data integrity option: logging# changes to the binary log between backups.# log_bin## Remove leading # to set options mainly useful for reporting servers.# The server defaults are faster for transactions and fast SELECTs.# Adjust sizes as needed, experiment to find the optimal values.# join_buffer_size = 128M# sort_buffer_size = 2M# read_rnd_buffer_size = 2Mdatadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sock# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid#最大连接数max_connections=1000\n 然后 :wq 退出编辑。‍‍‍‍‍‍‍\n5、新建用户和用户组‍\ncd /usr/local/mysql/groupadd mysql               # 创建用户组useradd -r -g mysql mysql    # 创建用户并且指定用户组chown -R mysql:mysql ./      # 修改当前文件的归属用户和用户组\n\n6、初始化数据库，分别执行如下命令\ncd /usr/local/mysql/mkdir ./data./bin/mysqld --user=mysql --basedir=/usr/local/mysql/ --datadir=/usr/local/mysql/data/ --initialize\n\n第三步命令如果报错：‍‍‍‍.&#x2F;bin&#x2F;mysqld: error while loading shared libraries: libaio.so.1: cannot open shared object file: No such file or directory 的话说明当前缺少了libaio.so.1库，执行如下命令安装libaio.so.1库。\nyum install -y libaio\n\n安装成功后再次执行第三条命令，出现如下界面则说明安装成功了，最后的初始化密码要记住。\n\n7、添加MySQL到系统服务中并且建立软连接‍\ncp -a ./support-files/mysql.server /etc/init.d/mysqlchmod +x /etc/init.d/mysqlchkconfig --add mysqlchkconfig --list mysql #检查是否生效\n\n\n建立软连接\nln -s /usr/local/mysql/bin/mysql /usr/bin\n\n8、启动并且登录MySQL\n执行 service mysql start 命令，出现 Success字样则说明启动成功。 \n\n登录MySQL‍\nmysql -u root -p\n\n\n回车然后输入刚才的初始化密码，输入时光标并不会有任何变化。  \n修改用户密码\nALTER USER &quot;root&quot;@&quot;localhost&quot; IDENTIFIED  BY &quot;你的新密码&quot;;FLUSH PRIVILEGES;  #配置生效\n\n\n修改如下配置，使得root用户可以远程连接。‍‍\nuse mysql;  update user set host=&#x27;%&#x27; where user =&#x27;root&#x27;;FLUSH PRIVILEGES;    #配置生效\n\n​\t\t\n四、MySQL的数据模型关系型数据库（RDBMS）概念：建立在关系型模型基础上，由多张相互连接的二维表组成的数据库。\n特点：&emsp;&emsp; - 1、使用表结构存储。格式统一便于维护。&emsp;&emsp; - 2、使用SQL语言操作，标准统一使用方便。\n\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 七、SQL语言中的约束","url":"/2023/08/01/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E4%B8%83%E3%80%81SQL%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%BA%A6%E6%9D%9F/","content":"1、概念  \n约束是作用于表中字段上的规则，用于限制存储在表中的数据。‍\n2、目的‍\n保证数据库中数据的正确性、有效性和完整性。‍‍‍‍\n3、分类‍\n\n\n\n约束\n描述\n关键字\n\n\n\n非空约束\n限制该字段的数据不能为null\nNOT　NULL\n\n\n唯一约束\n保证该字段所有的值都是唯一不重复的\nUNIQUE\n\n\n主键约束\n主键是一行数据的唯一标识，要求非空且唯一\nPRIMARY KEY\n\n\n默认约束\n保存数据时如果未指定该字段的值则使用默认约束\nDEFAULT\n\n\n检查约束（8.0.16版本之后）\n保证字段值满足某一个条件\nCHECK\n\n\n外键约束\n用来将两张表的数据之间建立连接，保证数据的一致性和完整性\nFOREIGN KEY\n\n\n4、外键约束\n创建外键\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名);\n\n删除外键  \nALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\n\n\n\n5、外键的删除&#x2F;更新行为\n\n\n\n行为\n说明\n\n\n\nNO ACTION\n当在父表中更新&#x2F;删除记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。（与RESTRICT一致）\n\n\nRESTRICT\n当在父表中更新&#x2F;删除记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。（与NO ACTION一致）\n\n\nCASCADE\n当在父表中更新&#x2F;删除记录时，首先检查该记录是否有对应外键，如果有删除&#x2F;更新外键在子表中的记录。（与NO ACTION一致）\n\n\nSET NULL\n当在父表中删除记录时，首先检查该记录是否有对应外键，如果有则将子表中该外键的值置为null。\n\n\nSET　DEFAULT\n父表有变更时，字表将外键列设置为一个默认值。（InnoDB引擎不支持）\n\n\n语法：\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名) ON UPDATE CASCADE ON DELETE CASCADE;","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 三、SQL语言中DML语句的语法","url":"/2023/07/28/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E4%B8%89%E3%80%81SQL%E8%AF%AD%E8%A8%80%E4%B8%ADDML%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%AF%AD%E6%B3%95/","content":"DML：数据操作语言，用来对数据库表中的数据进行增删改操作。\n\n\n添加语句（INSERT）\n给指定字段添加数据：\nINSERT INTO 表名(字段1, 字段2) VALUES(值1, 值2);\n\n给所有的字段添加数据：‍‍‍‍\nINSERT INTO 表名 VALUES(值1, 值2 ... 值n);\n\n批量添加数据：\nINSERT INTO 表名(字段1, 字段2) VALUES(值1, 值2), (值1, 值2)(值1, 值2);\nINSERT INTO 表名 VALUES(值1, 值2 ... 值n), (值1, 值2 ... 值n), (值1, 值2 ... 值n);\n\n添加语句注意的事项：  \n&emsp;&emsp;&emsp;&emsp;1、插入数据时，指定的字段顺序要和值的顺序一一对应。\n&emsp;&emsp;&emsp;&emsp;2、字符串和日期类型应该包裹在引号中。‍‍\n&emsp;&emsp;&emsp;&emsp;3、输入的数据大小应该在字段规定范围内。\n\n\n修改语句（UPDATE）\n修改表中的数据:\nUPDATE 表名 SET 字段1=值1, 字段2=值2 [WHERE 条件];\n\n修改语句的条件没有时会更新整个表的数据。\n\n\n删除语句（DELETE）  \n删除表中的数据:\nDELETE FROM 表名 [WHERE 条件];\n\n删除语句的条件没有时会删除整个表的数据。\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 九、SQL语言中的事物","url":"/2023/08/02/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E4%B9%9D%E3%80%81SQL%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%BA%8B%E7%89%A9/","content":"一、事物的简介‍‍1、什么是事物\n事物是一组操作的集合，它是一个不可分割的工作单元，事物会把所有的操作作为一个整体一起向系统提交或者撤销操作请求，即这些操作要么全部同时成功，要么同时失败。\nMySQL数据库是自动提交事物的。‍‍‍‍\n  \n\n二、事物的操作1、查看、设置事物的提交方式\nSELECT @@AUTOCOMMIT;SET @@AUTOCOMMIT = 0;    (0: 手动提交；1:自动提交)\n\n2、提交事物‍\nCOMMIT;\n\n\n3、回滚事物\nROLLBACK;\n\n4、开启事物\nSTART TRANSACTION;或者BEGIN;\n\n  \n\n三、事物的四大特性 ACID‍‍‍1、原子性（Atomicity）：事物是不可分割的最小操作单元，要么全部成功，要么全部失败。‍‍\n2、一致性（Consistency）：事物完成时，数据的总量保持不变，必须使所有的数据都保持一致的状态。‍\n3、隔离性（Isolation）：数据库提供的隔离机制，保证事物在不受外部并发操作影响的环境下独立运行（A事物的操作不会影响正在进行的B事物）。\n4、持久性（Durability）：事物一旦提交或者回滚，他对数据库中的改变都是永久的。\n\n\n四、并发事物产生的问题‍1、脏读：一个事物读取到了另一个事物没提交的数据。‍‍\n2、不可重复读：一条事物先后执行同样的SQL，但是两次读取的数据不同（同一行数据每次查询不同）。‍‍‍‍‍\n3、幻读：一个事物在执行查询时，每次查询到的数据行数不一致（某一行数据一会存在一会又不存在）。‍\n\n\n五、事物的隔离级别\n\n\n隔离界别\n脏读\n幻读\n不可重复读\n\n\n\nRead Uncommitted\n✔️\n✔️\n✔️\n\n\nRead Committed\n✖️\n✔️\n✔️\n\n\nRepeatable Read\n✖️\n✖️\n✔️\n\n\nSerializable\n✖️\n✖️\n✖️\n\n\n事物的隔离界别越高，数据越安全，但是性能越低。\n查看事物的隔离级别\nSELECT @@TRANSACTION_ISOLATION;\n\n设置事物的隔离级别\nSET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZATION &#125;;","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 二、SQL分类以及DDL语句的语法","url":"/2023/07/28/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E4%BA%8C%E3%80%81SQL%E5%88%86%E7%B1%BB%E4%BB%A5%E5%8F%8ADDL%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%AF%AD%E6%B3%95/","content":"一、SQL的分类‍DDL（Date Definiition Lanhuage）：数据定义语言，用来定义数据库对象（数据库、表、字段等）。 create table 表名;\nDML（Data Manipulation Language）：数据操作语言，用来对数据库中的数据进行增删改查。 alter table 表名 add 字段名 类型(长度);\nDQL（Data Query Language）：数据查询语言，用来查询数据库中表里面的数据。\nselect * from 表名;\n\nDCL（Data Control Language）：数据控住语言，用来创建用户，控制用户对数据库的访问权限。‍\ngrant all privileges on *.* to &#x27;XXX&#x27;@&#x27;%&#x27; identified by &#x27;XXX&#x27; with grant option;\n\n\n\n二、DDL在数据库上的操作查询所有数据库: \nSHOW DATABASES;\n查询当前数据库：  \nSHOW DATABASE();\n 创建数据库：  \nCREATE DATABASE [IF NOT EXISTS] 库名 [DEFAULT CHARSET utf8mb4];\n 删除数据库：‍‍‍‍‍‍‍‍\nDROP DATABASE [IF NOT EXISTS] 库名;\n 使用数据库：\nUSE 库名;\n\n\n\n三、DDL在表上操作查询当前数据库中的所有表：\nSHOW TABLES;\n查询表结构（不会展示字段注释）：  \nDESC 表名;\n查询表的创建语句：\nSHOW CREATE TABLE 表名;\n 创建表：  \ncreate table 表名(    字段1 字段1类型 [comment 字段1注释],    字段2 字段2类型 [comment 字段2注释],    字段3 字段3类型 [comment 字段3注释],    ......    字段n 字段n类型 [comment 字段n注释])[comment 表注释];\n 添加字段：\nALTER TABLE 表名 ADD 字段名 类型(长度);\n 修改字段的数据类型：\nALTER TABLE 表名 MODIFY 字段名 字段类型(长度);\n修改字段的名称和类型：‍‍\nALTER TABLE 表名 CHANGE 旧字段名 新字段名 字段类型(长度);\n 删除字段：\nALTER TABLE 表名 DROP 字段名;\n 修改表名称：\nALTER TABLE 表名 RENAME TO 新表名;\n删除表：‍‍‍‍\nDROP TABLE [IF EXISTS] 表名;TRUNCATE TABLE 表名;\n\nDROP：物理删除表结构加数据。‍‍‍‍TRUNCATE：物理删除表结构加数据后 重新创建表。\n\n\n四、DDL语句中的数据类型1、数值类型  \n\n\n\n类型\n大小\n描述\n\n\n\nTINYINT\n1 bytes\n小整数值\n\n\nSMALLINT\n2 bytes\n大整数值\n\n\nMEDIUMINT\n3 bytes\n大整数值\n\n\nINT 或者 INTEGER\n4 bytes\n大整数值\n\n\nBIGINT\n8 bytes\n极大整数值\n\n\nFLOAT\n4 bytes\n单精度浮点整数\n\n\nDOUBLE\n8 bytes\n双精度浮点整数\n\n\nDECIMAL\n\n小数[精确定点数，依赖于M（精度）和D（标度）]\n\n\n2、字符串类型‍‍‍‍‍‍\n\n\n\n类型\n大小\n描述\n\n\n\nCHAR\n0 - 255 bytes\n定长字符串\n\n\nVARCHAR\n0 - 65536 bytes\n变长字符串\n\n\nTINYBLOG\n0 - 255 bytes\n不超过255个字符的二进制数据\n\n\nTINYTEXT\n0 - 255 bytes\n短文本字符串\n\n\nBLOG\n0 - 65536 bytes\n二进制形式的长文本数据\n\n\nTEXT\n0 - 65536 bytes\n长文本数据\n\n\nMEDIUMBLOG\n0 - 16777215 bytes\n二进制形式的中等长度文本数据\n\n\nMEDIUMTEXT\n0 - 16777215 bytes\n中等长度文本数据\n\n\nLONGBLOG\n0 - 4294967295 bytes\n二进制形式的极大文本数据\n\n\nLONGTEXT\n0 - 4294967295 bytes\n极大文本数据\n\n\n&emsp;&emsp; char(10): 即使存储一个字符，剩下的使用空格占位，效率高。&emsp;&emsp; varchar(10): 存储一个字符，实际占用一个字符，效率低一点。   \n3、日期时间类型\n\n\n\n类型\n大小\n范围\n格式\n描述\n\n\n\nDATE\n3\n1000-01-01 至 9999-12-31\nYYYY-MM-DD\n日期值\n\n\nTIME\n3\n-838:59:59 至 838:59:59\nHH:MM:SS\n时间值或持续时间\n\n\nYEAR\n1\n1901 至 2155\nYYYY\n年份值\n\n\nDATETIME\n8\n1000-01-01 00:00:00 至 9999-12-31 23:59:59\nYYYY-MM-DD HH:MM:SS\n混合日期和时间值\n\n\nTIMESTAMP\n4\n1970-01-01 00:00:01 至 2038-01-19 03:14:07\nYYYY-MM-DD HH:MM:SS\n混合日期和时间值，时间戳\n\n\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 五、SQL语言中DCL语句的语法","url":"/2023/07/28/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E4%BA%94%E3%80%81SQL%E8%AF%AD%E8%A8%80%E4%B8%ADDCL%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%AF%AD%E6%B3%95/","content":"DCL：数据控制语言，用来管理数据库用户、数据库访问权限。\n一、DCL管理用户创建用户\nCRAETE USER &#x27;用户名&#x27;@&#x27;主机&#x27; IDENTIFIED BY &#x27;密码&#x27;;\n\n主机:  localhost:当前主机；%:任意机器。‍‍‍‍‍‍\n查询用户\nSELECT * FROM USER;\n\n修改用户密码  \nALTER USER &#x27;用户名&#x27;@&#x27;主机&#x27; IDENTIFIED WITH mysql_native_password &#x27;密码&#x27;;\n\n删除用户  \nDROP USER &#x27;用户名&#x27;@&#x27;主机&#x27;;\n\n  \n\n二、DCL权限控制‍‍mysql中常用的权限列表‍‍‍‍‍‍‍\n\n\n\n权限\n说明\n\n\n\nALL, ALL PRIVILEGES\n所有权限\n\n\nSELECT\n查询数据\n\n\nINSERT\n插入数据\n\n\nUPDATE\n修改数据\n\n\nDELETE\n删除数据\n\n\nALTER\n修改表\n\n\nDROP\n删除数据库&#x2F;表&#x2F;视图\n\n\nCREATE\n创建数据库&#x2F;表\n\n\n查询权限\nSHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机&#x27;;\n\n授予权限  \nGRANT 权限列表 ON 数据库.表名 TO &#x27;用户名&#x27;@&#x27;主机&#x27;;\n\n撤销权限  \nREVOKE 权限列表 ON 数据库.表名 FROM &#x27;用户名&#x27;@&#x27;主机&#x27;;\n\n‍‍‍\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 八、SQL语言中的多表关系","url":"/2023/08/02/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%85%AB%E3%80%81SQL%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A4%9A%E8%A1%A8%E5%85%B3%E7%B3%BB/","content":"笛卡尔积：笛卡尔积是指在数学中，两个集合A集合和B集合的所有组合情况（多表查询时需要消除无效的笛卡尔积）。\n多表查询的分类1、内连接（C表示部分）\n\n隐式内连接    SELECT * FROM 表1, 表2 WHERE 条件;显示外连接    SELECT * FROM 表1 [INNER]JOIN 表2 ON 条件;\n\n2、外连接\n\n左外连接表示A和C部分\nSELECT 字段 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件;\n\n右外连接表示B和C部分  \nSELECT 字段 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件;\n\n3、自连接\nSELECT 字段 FROM 表A 别名A JOIN 表A 别名B ON 条件;\n\n4、联合查询‍\n    多次查询的结果合并起来，形成一个新的查询结果集。多张表的列数和类型需要保持一致。\nSELECT 字段列表 FROM 表A...UNION [ALL] SELECT 字段列表 FROM 表B...\n\nUNION: 查询结果去重‍\nUNION ALL: 查询结果不会去重‍‍‍‍‍‍‍‍‍\n4、子查询\nSQL语句中嵌套SELECT语句，称为嵌套语句，又称子查询。‍‍‍‍\nSELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 六、SQL语言中函数","url":"/2023/08/01/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%85%AD%E3%80%81SQL%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%87%BD%E6%95%B0/","content":"函数：是指一段可以直接被另一段程序调用的程序或代码。\n一、字符串函数\n\n\n函数\n功能\n\n\n\nCONCAT(S1, S2, …, Sn)\n字符串拼接，将字符串S1，S2…Sn拼接成一个新字符串\n\n\nLOWER(str)\n将字符串str全部转为小写\n\n\nUPPER(str)\n将字符串str全部转为大写\n\n\nLPAD(str, n, pad)\n左填充，用字符串pad对str的左边进行填充，达到n个字段的长度\n\n\nRPAD(str, n, pad)\n右填充，用字符串pad对str的右边进行填充，达到n个字段的长度\n\n\nTRIM(str)\n去掉字符串头部和尾部的空格\n\n\nSUBSTRING(str, start, len)\n返回字符串str从start开始起的len个长度的字符串\n\n\n1、CONCAT函数\nSELECT CONCAT(&#x27;hello&#x27;, &#x27;mysql&#x27;);输出：hello mysql\n\n2、LOWER函数‍‍\nSELECT LOWER(&#x27;HELLO&#x27;);输出：hello\n\n3、UPPER函数\nSELECT UPPER(&#x27;hello&#x27;);输出：HELLO\n\n4、LPAD函数  \nSELECT LPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);输出：---01\n\n5、RPAD函数\nSELECT RPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);输出：01---\n\n6、TRIM函数（只能去除两端的空格，不能去除中间的空格）\nSELECT TRIM(&#x27; Hello Trim &#x27;);输出：Hello Trim\n\n7、SUBSTRING\nSELECT SUBSTRING(&#x27;Hello MySQL&#x27;, 1, 5);输出：Hello\n\n  \n\n二、数值函数‍‍\n\n\n函数\n功能\n\n\n\nCEIL(x)\n向上取整\n\n\nFLOOR(x)\n向下取整\n\n\nMOD(x, y)\n返回x&#x2F;y的模\n\n\nRAND()\n返回0～1内的随机数\n\n\nROUND(x, y)\n求参数x的四舍五入的值，保留y位小数\n\n\n1、CEIL函数\nSELECT CEIL(1.6);    输出：1SELECT CEIL(1.1);    输出：1\n\n2、FLOOR函数\nSELECT FLOOR(1.6);    输出：2SELECT FLOOR(1.1);   输出：2\n\n3、MOD函数(求余数)  \nSELECT MOD(3, 4);   输出：3SELECT MOD(6, 4);    输出：2\n\n4、RAND  \nSELECT RAND();       输出：0～1之间的随机数\n\n5、ROUND‍\nSELECT ROUND(2.34, 2);     输出：2.34SELECT ROUND(1.236, 2);    输出：1.24\n\n  \n\n三、日期函数‍‍‍‍\n\n\n函数\n功能\n\n\n\nCURDATE()\n返回当前日期\n\n\nCURTIME()\n返回当前时间\n\n\nNOW()\n返回当前日期和时间\n\n\nYEAR(date)\n返回执行date的年份\n\n\nMONTH(date)\n返回指定date的月份\n\n\nDAY(date)\n返回指定date的日期\n\n\nDATE_ADD(date, INTERVAL expr type)\n返回一个日期&#x2F;时间加上一个时间间隔expr后的时间值\n\n\nDATEDIFF(date1, date2)\n返回起始时间date1和结束时间date2之间的天数\n\n\n1、CURDATE\nSELECT CURDATE();    输出：2023-07-13\n\n2、CURTIME\nSELECT CURTIME();    输出：08:37:26\n\n3、NOW\nSELECT NOW();        输出：2023-07-13 08:38:33\n\n4、YEAR、MONTH、DAY\nSELECT YEAR(NOW());      输出：2023SELECT YEAR(MONTH());    输出：7SELECT YEAR(DAY());      输出：13\n\n5、DATE_ADD\nSELECT DATE_ADD(NOW(), INTERVAL 70 DAY);输出：2023-09-21 08:40:13SELECT DATE_ADD(NOW(), INTERVAL -10 MONTH);输出：2022-09-13 08:40:13\n\n6、DATEDIFF(第一个时间减第二个时间)\nSELECT DATEDIFF(&#x27;2023-07-10&#x27;, &#x27;2023-07-01&#x27;);输出：9\n\n  \n\n四、流程控制函数‍‍\n\n\n函数\n功能\n\n\n\nIF(value, t, f)\n如果value为true则返回t，否则返回f。\n\n\nIFNULL(val1, val2)\n如果val1不为空则返回val1，否则返回val2。\n\n\nCASE WHEN [val1] THEN [res1] … ELSE [default] END\n如果val1为true则返回res1…否则返回默认值default。\n\n\nCASE [expr] WHEN [val1] THEN [res1] … ELSE [default] END\n如果表达式expr的值为val1则返回res1…否则返回默认值default。\n\n\n1、IF\nSELECT IF(true, &#x27;OK&#x27;, &#x27;Error&#x27;);    输出：OK\n\n2、IFNULL‍\nSELECT IFNULL(&#x27;OK&#x27;, &#x27;Default&#x27;);    输出：OKSELECT IFNULL(&#x27;&#x27;, &#x27;Default&#x27;);      输出：SELECT IFNULL(NULL, &#x27;Default&#x27;);    输出：Default\n\n3、CASE WHEN THEN ELSE END\n查询员工姓名和城市，如果城市是上海和北京返回一线城市，其他返回二线城市SELECT \tname, \tCASE work_address WHEN &#x27;上海&#x27; THEN &#x27;一线&#x27; WHEN &#x27;北京&#x27; THEN &#x27;一线&#x27; ELSE &#x27;二线&#x27; END FROM worker;","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 十、数据库中的存储引擎","url":"/2023/08/02/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%8D%81%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/","content":"一、MySQL的体系结构‍\n连接层：最上层是一些客户端和链接服务，主要完成一些连接处理、授权认证以及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具备的操作权限。‍\n服务层：主要完成大多数的核心功能，如SQL接口，并完成查询的缓存，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能在这一层实现，如存储过程和视图等。‍‍‍‍‍‍‍‍‍\n引擎层：存储引擎真正的负责了MYSQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样就可以根据自己的需要来选择合适的存储引擎。‍\n存储层：主要是将数据存储在文件系统之上并完成与存储引擎的交互。‍‍‍‍\n  \n\n二、存储引擎的简介1、什么是存储引擎‍‍‍\n存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表而非基于库的，所以存储引擎也可被称为表类型。‍‍‍‍\n2、查看数据库支持的存储引擎‍‍\nSHOW ENGINES;\n\n\n3、查看已创建表的存储引擎‍\nSHOW CREATE TABLE tb_wxuser;\n\n\n\n\n三、常见的存储引擎1、InnoDB存储引擎：InnoDB是一种兼顾可靠性和高性能的通用存储引擎，在MySQL5.5之后InnoDB是默认的存储引擎。\nInnoDB的特点：\n（1）、DML遵循ACID模型，支持事物。‍\n（2）、支持行及锁，提高并发访问性能。‍‍‍‍\n（3）、支持外键FOREIGN KEY约束，保证数据的完整性和正确性。‍‍‍\nInnoDB的文件存储：\nXXX.ibd:XXX代表的是数据库的表名，InnoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm，sdi）、数据和索引。‍‍‍\n参数：innodb_file_per_table &#x3D; ON 表示每一个表对应一个ibd存储文件，OFF表示共用一个ibd存储文件。‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍\nInnoDB的存储结构：\n\n2、MyISAM存储引擎：MyISAM是MySQL早期的默认存储引擎。\nMyISAM引擎特点：  \n（1）：不支持事物、不支持外键。\n（2）：支持表锁但不支持行锁。\n（3）：访问速度较快。  \nMyISAM引擎的文件存储：\n\n3、Memory存储引擎：Memory引擎的表数据存储在内存中，容易受到硬件问题、断电等的影响，因此只能将这些表作为临时表或者缓存使用。\nMemory引擎特点：\n（1）、内存存放数据 。\n（2）、默认hash索引。\nMemory引擎文件存储：\nxxx.sdi: 存储表结构信息\n4、innoDB、MyISAM、Memory三者的区别\n\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 十一、数据库中的索引","url":"/2023/08/02/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%8D%81%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95/","content":"一、索引概述什么是索引‍‍?\n索引（index）是帮助MySQL高效获取数据的有序数据结构。在数据之外，数据库还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构之上实现高级查找算法，这种数据结构就是索引。‍‍‍‍‍‍‍‍\n索引的优点‍‍\n    1、提高了检索数据的效率。\n    2、通过索引列对数据进行排序，降低数据的排序成本。\n索引的缺点：\n    1、索引也要占用空间。\n    2、索引提高了查询效率的同时也降低了更新数据（INSERT、UPDATE…）的效率。‍‍‍‍‍‍\n\n\n二、索引的语法创建索引\nCREATE [UNIQUE | FULLTEXT | ] INDEX index_name ON table_name(index_col_name, ...);\n\n查看索引\nSHOW INDEX FROM table_name;\n\n删除索引\nDROP INDEX index_name ON table_name;\n\n\n三、索引结构MySQL的索引是在引擎层实现的，不同的存储引擎有不同的结构，主要包括下面几种：‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍\n\n\n\n索引结构\n描述\n\n\n\nB+Tree索引\n最常见的索引类型，大部分引擎都支持B+树索引。\n\n\nHash索引\n底层使用hash表实现的索引，不支持范围查询，只有精确匹配的列才有效。\n\n\nR-tree索引（空间索引）\n空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少。\n\n\nFull-text（全文索引）\n是一种通过建立倒排索引，快速匹配文档的方式。类似于Lucene，Solr，ES。\n\n\n不同的索引在各个存储引擎中的支持情况：\n\n\n\n索引\nInnoDB\nMyISAM\nMemory\n\n\n\nB+Tree索引\n支持\n支持\n支持\n\n\nHash索引\n不支持\n不支持\n支持\n\n\nR-tree索引\n不支持\n支持\n不支持\n\n\nFull-text（全文索引）\n5.6版本之后支持\n支持\n不支持\n\n\n数据结构在线模拟：https://www.cs.usfca.edu/~galles/visualization/Algorithms.html\n1、Btree和Btree索引\n二叉树（大于祖先节点在右侧，小于祖先节点在左侧）\n\n二叉树的缺点‍‍‍\n(1)、顺序插入时会形成一个链表，查询性能大大降低。(2)、数据量较大的情况下层级较深，检索速度慢。‍‍‍‍‍‍‍‍‍‍‍\n红黑树（自平衡的二叉树）‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍\n\n红黑树的缺点：数据量较大的情况下层级较深，检索速度慢。\nB树（多路平衡二叉树）\n以一颗最大度数（max-degree）为5（5阶）的b-tree为例（每个节点最多可存储4个可以，5个指针）。‍‍\n树的度数指得是一个节点的子节点的个数。\n\n2、B+树和B+树索引‍‍‍‍\n以一棵最大度数为4的b+为例‍‍‍‍‍\n\n（1）、所有的数据都会在叶子结点出现\n（2）、叶子结点会形成一个单向列表\nMySQL中的B+树\n\nMySQL数据结构对经典的B+树进行了优化。在原有B+树基础之上增加了一个只下过相邻叶子结点的链表指针，就形成了带有顺序指针的B+树，提高了区间访问的性能。  \n3、hash索引\n采用一定的hash算法，将键值转换成新的hash值，映射到对应到槽位上，然后存储到hash表中。‍‍‍‍‍‍‍‍\n如果两个（或多个）键值映射到同一个槽位上，他们就产生了hash冲突（也成hash碰撞），hash冲突可以通过链表来解决。‍\n‍\nHash索引的特点：\n（1）、hash索引只能用于对等比较（&#x3D;，in），不支持范围查询（between，&lt;， &gt;）。‍‍\n（2）、无法利用索引完成排序。‍\n（3）、查询效率高，通常只需要一次检索即可（hash冲突时会去查询链表），效率高于B+tree索引。‍‍‍‍‍\n思考：为什么InnoDB索引选择B+树而非二叉树或者红黑树或者B树？‍‍‍‍‍‍\n如果是顺序插入的话，二叉树会形成链表，导致树的层级较深，从而降低查找的效率，红黑树本质也是二叉树，也会有该问题。相对于二叉树，B+树层级更少，效率更高。‍‍‍‍‍‍‍\nB树非叶子结点也会存储数据，导致磁盘页上存放的数据变少，相同数据量的情况下，树的高度会增加，导致效率降低。B+树的叶子节点为双向链表，便于范围查询和排序。‍‍‍‍‍\nHash索引不支持范围查询和排序。‍‍‍‍‍\n  \n\n四、索引分类\n\n\n分类\n含义\n特点\n关键字\n\n\n\n主键索引\n针对于表中主键创建的索引\n默认自动创建，只有一个。\nPRIMARY\n\n\n唯一索引\n避免同一表中某数据列的值重复\n可以有多个\nUNIQUE\n\n\n常规索引\n快速定位特定数据\n可以有多个\n\n\n\n全文索引\n全文索引查找的是文本中的关键词，而不是比较索引中的值。\n可以有多个\nFULLTEXT\n\n\n在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：\n\n\n\n分类\n含义\n特点\n\n\n\n聚集索引（Clustered Index）\n将数据存储与索引放在了一起，索引结构的叶子结点保存了行数据。\n必须有，而且只有一个。\n\n\n二级索引（Secondary Index）\n将数据与索引分开存储，索引结构的叶子结点关联的是对应的主键。\n可以存在多个。\n\n\n聚集索引的选取规则：‍‍‍‍‍‍‍‍\n    1、如果存在主键，主键就是聚集索引。\n    2、如果不存在主键，将使用第一个唯一索引作为聚集索引。\n    3、如果表没有主键或者没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。‍‍\n聚集索引和二级索引的图示‍‍\n\n聚集索引叶子节点存储的是每一行的数据（row），二级索引每一个叶子结点存储的是对应行的id。  \n聚集索引和二级索引在查询中的执行过程：‍‍‍\n\n1、首先执行where条件后的查询，使用二级索引根据name拿到id。\n2、根据id到聚集索引查询行数据。（回表查询）\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 十二、SQL性能分析和优化","url":"/2023/08/07/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%8D%81%E4%BA%8C%E3%80%81SQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E4%BC%98%E5%8C%96/","content":"一、查看SQL的执行频率通过SQL的执行频率可以确定当前数据库执行哪类操作比较多，然后做出对应的优化措施。\n通过如下命令可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT等操作的执行频次。\nSHOW GLOBAL STATUS LIKE &#x27;Com_______&#x27;\n\n\n\n\n二、慢查询日志慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。\nMySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：\n# 开启MySQL的慢日志查询开关slow_query_log=1# 设置慢日志的查询时间，SQL语句执行时间超过指定的值(如下超过10秒则为慢查询)，则会视为慢查询，记录慢查询日志。long_query_time=10\n\n配置完毕以后需重启MySQL服务，慢日志信息记录在文件：/var/lib/mysql/localhost-show.log中。\n查询慢日志查询是否开启，如下命令：\nSHOW VARIABLES like &#x27;slow_query_log&#x27;;\n\n输出Value值为：ON 则说明慢日志查询开启。\n\n\n三、show profiles命令在实际的业务中，有些SQL查询比较简单，但是查询占用的时间刚好小于慢日志记录设置的时间，导致这类慢SQL不能被捕捉到。\nshow profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够查看到当前MySQL是否支持profile操纵。\nSELECT @@have_profiling;\n\n输出值为：YES则说明当前数据库支持profile。\n默认profile是关闭的，可以通过命令开启GLOBAL或者SESSION级别的profiling。\nSET [GLOBAL | SESSION] profiling = 1;\n\nprofile相关的一些命令\n# 查看每一条SQL的耗时基本情况show profiles;# 查看指定query的SQL语句的各个阶段的耗时情况,query_id:上一步的idshow profile for query [query_id];# 查看指定SQL的CPU占用情况show profile cpu for query [query_id];\n\n\n\n四、explain命令EXPLAIN或者DESC命令用来获取MySQL是如何执行SELECT语句的信息，包括SELECT语句执行过程中表如何连接和连接顺序等信息。\n语法\n# 直接在select语句前面加上关键字 explain/descEXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;\n\nEXPLAIN展示的各个字段的含义：\n\n\n\n字段名\n含义\n\n\n\nid\n查询的序列号，表示查询中执行select字句或者是操作表的顺序。（id越大越先被执行，id相同时按照从上往下的顺序执行查询）\n\n\nselect_type\n表示select的类型，常见的取值有SIMPLE（简单表，即不使用表链接或者子查询）、PRIMARY（主查询，即外层查询）、UNION（UNION中的第二个或者后面的查询）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等。\n\n\ntype\n表示连接类型，性能由好到差为NULL、SYSTEM、CONST、EQ_REF、REF、RANGE、INDEX、ALL。\n\n\npossible_key\n显示可能用在这张表上的索引，一个或者多个。\n\n\nkey\n实际使用的索引，没有则为NULL。\n\n\nkey_length\n表示索引使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精度的情况下，长度越短越好。\n\n\nrows\nMySQL认为必须要执行查询的行数，在InnoDB引擎中是一个估算值，可能并不总是准确的。\n\n\nfiltered\n表示返回结果的行数占需要读取行数的百分比，filtered的值越大越好。\n\n\nextra\n额外信息\n\n\nextra中显示的信息，MySQL版本不通则显示的不同。\n五、索引的使用规则以及失效场景最左前缀法则：如果索引了多列（联合索引），要遵守最佳左前缀法则。最左前缀法则是指查询从索引的最左列开始，并且不跳过索引中的列。如果跳过了索引中的某一列，索引将部分失效（跳过列后方的字段索引失效）；\n\nwhere条件后面列的顺序可以和索引中定义的顺序不一致。\n\nSQL提示：是优化数据库的一个重要手段，简单来说就是在SQL语句中加入一些人为的提示来达到优化操作的目的。\n\nuse index;  告诉数据库你应该使用哪一个索引（建议使用）\nSELECT 字段列表 FROM 表名 use index(index_name) WHERE 条件;\n\n\nignore index;  告诉数据库你不要使用哪一个索引\nSELECT 字段列表 FROM 表名 ignore index(index_name) WHERE 条件;\n\n\nforce index;  告诉数据库你必须要使用哪一个索引（强制使用）\nSELECT 字段列表 FROM 表名 force index(index_name) WHERE 条件;\n\n覆盖索引：尽量使用覆盖索引（查询使用了索引，并且查询的字段全部可以在索引中找到），避免使用SELECT *（极易出现回表查询）。\n\n现有如下表结构，分别对主键ID和字段name建立索引：\n\n\n\n\nID\nNAME\nGENDER\nCREATEDATE\n\n\n\n2\nArm\n1\n2023-08-22\n\n\n4\nLily\n1\n2023-08-01\n\n\n5\nRosy\n0\n2023-03-10\n\n\n8\nZoom\n1\n2023-11-09\n\n\n\n聚集索引（id）：\n\n\n\n辅助索引（name）：\n\n\n\n分别进行以下查询：\n\nSELECT * FROM tb_stu WHERE id = 2;走聚集索引，一次就可查询出数据。SELECT id, name FROM tb_stu WHERE name = &#x27;Arm&#x27;;走辅助索引即可查询出需要的所有数据（覆盖索引）。SELECT id, name, gender FROM tb_stu WHERE name = &#x27;Arm&#x27;;首先根据辅助索引查询，只能查询出name和id字段，然后再使用id字段去聚集索引中查询gender字段（回表查询）。\n\n\n思考：一张表有四个字段（id, name, password, status），由于数据量较大需要对以下SQL进行优化，该如何进行才是最优方案？\nSELECT id, name, password, status FROM tb_user WHERE name = &#x27;Tom&#x27;;\n\n方案1: 为字段name建立索引。\n如果只为name字段建立索引的话，查询回进行两次，首先走辅助索引查询出name和id，然后再使用主键索引根据id查询password和status字段，涉及到了回表操作。\n方案2: 为字段name和password以及status字段建立索引。\n此时where条件会使用建立的索引（最佳左前缀），并且根据索引就能查询出需要的数据，不需要回表等操作，因此性能最高。\n\n前缀索引：当字段类型为字符串（varchar，text）时，有时候需要索引很长的字符串（比如博客中的内容），只会让索引变得很大，查询时会浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀建立索引，这样可以大大减少索引空间进而提示查询效率。\n语法：\nCREATE INDEX index_name ON table_name(column(n));\t-- n:前缀长度\n\n如何决定前缀的长度：可以根据前缀的选择性来决定，而前缀的选择性是指不重复的索引值（基数）和数据总量的比值，选择性越高则查询效率越高，唯一索引的选择性为1，是最好的选择性，性能也是最高的。\n选择行计算：SELECT count (distinct email)/count(*) FROM tb_user;\t                -- 1SELECT count (distinct substring(email,1,4))/ count(*) FROM tb_user;\t-- 0.9876\n\n范围查询：联合索引中，出现范围查询（&gt;, &lt;）时，范围查询右侧的索引将失效。\n\n大于等于, 小于等于 不会使得索引失效，因此在业务允许的情况下尽量使用大于等于代替大于，用小于等于代替小于。\n\n索引列上运算：在索引列上进行计算操作将导致索引失效。\n字符串不加引号：使用字符串列时不加引号会导致索引失效（隐式转换）。\n模糊查询：如果仅是尾部进行模糊匹配索引不会失效，如果是头部进行模糊匹配则会失效。\n\nWHERE name like ‘%张三’；\t索引失效\nWHERE name like ‘张三%’；\t索引有效\n\nOR连接的条件：用or分隔开的条件，如果or前面的条件中的列有索引，而后面的列中没有索引，那么涉及到的索引都不会生效。or前后的条件都有索引时会生效。\n数据分布影响：如果MySQL评估使用索引比全表更慢时则不会使用索引。\n如果使用索引查出的数据量大于全表的数据量的1&#x2F;2，MySQL会使用全表扫描。\n\n对字段使用not null或者is not null时，MySQL也会评估是走索引还是全表扫描。\n\n\n\n六、索引的设计规则\n针对数据量较大且查询比较频繁的表建立索引。\n\n针对常作为查询条件（where）、排序（order）、分组（group by）操作的字段建立索引。\n\n尽量选择区分度较大的列作为索引，尽量选择唯一索引，区分度越高，使用索引的效率越高。\n\n如果是字符串类型的字段并且字段的长度较长，可以针对字段的特点建立前缀索引。\n\n尽量使用联合索引，减少单列索引，查询时联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。\n\n控制索引的数量，索引并不是越多越好，索引越多，维护索引的成本就越高，增删改的效率也会被影响。\n\n如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好的确定哪一个索引可最有效的用于查询。\n\n\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 四、SQL语言中DQL语句的语法","url":"/2023/07/28/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%9B%9B%E3%80%81SQL%E8%AF%AD%E8%A8%80%E4%B8%ADDQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%AF%AD%E6%B3%95/","content":"DQL：数据查询语言，用来查询数据库中表里面的数据。\nDQL语法‍‍‍\nSELECT 字段列表 FROM 表名 WHERE 条件 GROUP BY 分组 HAVING 分组后的条件列表 ORDER BY 排序字段列表 LIMIT 分页参数;\n\n数据查询语言的分类：\n&emsp;&emsp;&emsp;&emsp;基本查询‍‍\n&emsp;&emsp;&emsp;&emsp;条件查询（WHERE）\n&emsp;&emsp;&emsp;&emsp;聚合查询（COUNT、MAX、MIN、AVG、SUM）\n&emsp;&emsp;&emsp;&emsp;分组查询（GROUP BY）‍‍‍‍‍\n&emsp;&emsp;&emsp;&emsp;排序查询（ORDER BY）\n&emsp;&emsp;&emsp;&emsp;分页查询（LIMIT）\n\n\n一、DQL的基础查询1、查询返回多个字段\nSELECT 字段1, 字段2, 字段n FROM 表名;SELECT * FROM 表名;\n\nselect * 可读性以及效率偏低，推荐 select 字段 的方式。\n2、设置别名\nSELECT 字段1 AS [别名1], 字段2 AS [别名2], ... 字段n AS [别名n] FROM 表名;\n\n3、去除重复记录\nSELECT DISTINCT 字段名 FROM 表名；\n\n\n\n二、DQL语句的条件查询‍‍\n\n\n比较运算符\n功能\n\n\n\n&gt;, &gt;&#x3D;\n大于，大于等于\n\n\n&lt;, &lt;&#x3D;\n小于，小于等于\n\n\n&#x3D;\n等于\n\n\n&lt;&gt;, !&#x3D;\n不等于\n\n\nBETWEEN…AND…\n在某个范围内（含最大值和最小值）\n\n\nIN(…)\n在IN之后的列表中\n\n\nLIKE 占位符\n模糊匹配\n\n\nIS NULL\n是NULL\n\n\n\n\n\n\n\n逻辑运算符\n功能\n\n\n\nAND 或 &amp;&amp;\n并且（多个条件同时成立）\n\n\nOR 或 ||\n或者（多个条件满足一个）\n\n\nNOT 或 ！\n非，不是\n\n\n1、查询年龄小于18的员工\nSELECT * FROM 表名 WHERE age &lt; 18;\n\n2、查询年龄等于20的员工‍\nSELECT * FROM 表名 WHERE age = 20;\n\n2、查询年龄不等于20的员工\nSELECT * FROM 表名 WHERE age != 20;SELECT * FROM 表名 WHERE age &lt;&gt; 20;\n\n3、查询没有年龄的员工信息  \nSELECT * FROM 表名 WHERE age is null;\n\n4、查询有年龄的员工信息  \nSELECT * FROM 表名 WHERE age is not null;\n\n6、查询年龄在20到30的员工信息\nSELECT * FROM 表名 WHERE age between 20 and 30;SELECT * FROM 表名 WHERE age &gt;= 20 and and &lt;= 30;\n\n7、查询年龄为20且性别为女的员工信息‍\nSELECT * FROM 表名 WHERE age = 20 and sex = &#x27;女&#x27;;\n\n8、查询年龄为20或者30或者40的员工信息\nSELECT * FROM 表名 WHERE age = 20 or age = 30 or age = 40;SELECT * FROM 表名 WHERE age in (20, 30, 40);\n\n9、查询姓名为两个字的员工(一个下划线代表一个字符)\nSELECT * FROM 表名 WHERE name like &#x27;__&#x27;;\n\n10、查询身份证号最后一位是X的员工信息‍‍‍‍\nSELECT * FROM 表名 WHERE id_card like &#x27;%X&#x27;;\n\n  \n\n三、DQL语句的聚合函数‍‍‍‍‍‍聚合函数作用：将一列数据作为一个整体进行纵向计算。\n注意：所有的null值不进行聚合函数计算。\n1、统计员工数量\nSELECT count(*) FROM 表名;SELECT count(字段名) FROM 表名;\n\n2、统计平均值\nSELECT avg(字段名) FROM 表名;\n\n3、查询最大值  \nSELECT max(字段名) FROM 表名;\n\n4、查询最小值‍\nSELECT min(字段名) FROM 表名;\n\n5、查询某个字段的和\nSELECT sum(字段名)  FROM 表名;\n\n  \n\n四、DQL语句的分组查询‍‍‍‍语法：SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY [HAVING 分组后的过滤条件]‍‍‍‍‍\n注意：\n&emsp;&emsp;&emsp;&emsp;1、分组查询的顺序为where -&gt; 聚合函数 -&gt; having‍‍‍‍‍‍‍‍‍‍‍‍\n&emsp;&emsp;&emsp;&emsp;2、分组之后查询的字段一般为聚合函数和分组字段，查询其他字段无意义。\n&emsp;&emsp;&emsp;&emsp;1、根据性别分组，查询男女员工的数量\nSELECT count(*) FROM 表名 GROUP BY gender;\n\n2、根据性别分组，查询男女员工的平均年龄  \nSELECT avg(age) FROM 表名 GROUP BY gender;\n\n3、查询年龄小于45的员工并且根据工作地址分组，获取员工数量大于3的工作地址\nSELECT count(*) as address_count FROM 表名 WHERE age &lt; 45 GROUP BY work_address HAVING address_count &gt;= 3;\n\n五、DQL语句的排序查询SQL语句中支持多个字段排序，排序方式有两种：ASC代表升序(默认值)，DESC代表降序。‍‍\n1、根据年龄对员工进行升序排列\nSELECT 字段名 FROM 表名 ORDER BY age ASC;\n\n2、根据入职时间进行降序排列  \nSELECT 字段名 FROM 表名 ORDER BY entry_date DESC;\n\n3、根据年龄对员工进行升序排序，年龄相同根据入职时间将序排列‍‍\nSELECT 字段名 FROM 表名 ORDER BY age ASC, entry_date DESC;\n\n  \n\n六、DQL语句的分页查询语法：SELECT 字段名 FROM 表名 LIMIT 起始索引,查询记录数;\n注意：LIMIT为MySQL的方言，不同数据库分页有不同的实现。‍‍\n1、查询第一页的员工数据，每页展示10条\nSELECT * FROM LIMIT 0,10;\n\n2、查询第二页的员工数据，每页展示10条  \nSELECT * FROM LIMIT 10,10;\n\n  \n\n七、DQL语句的执行顺序‍‍‍‍FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT\n","tags":["数据库","MySQL"]}]