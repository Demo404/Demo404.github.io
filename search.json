[{"title":"MySQL学习 ｜ 一、MySQL的基本概念和安装","url":"/2023/07/26/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E4%B8%80%E3%80%81MySQL%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%89%E8%A3%85/","content":"一、数据库相关的概念数据库（DB）：存储数据的仓库，数据是有组织的进行存储。\n数据库管理系统（DBMS）：操作和管理数据库的大型软件。‍‍‍‍‍‍‍\nSQL：操作关系型数据库的编程语言，定义了一套操作关系型数据库的统一标准。  \n​\t\t  \n二、主流的数据库管理系统1、Oracle：oracle公司研发，大型且收费。\n2、MySQL：小型，有免费有收费。‍\n3、PostgreSQL：中小型数据库，免费。\n4、SQLite：嵌入性数据库，安卓系统采用SQLite。\n. . . . . .‍‍‍\n​\t\t\n三、MySQL的安装和启动‍‍‍版本：\n社区版（MySQL Community Server）\n免费，MySQL不提供任何技术支持。\n\n商业版（MySQL Enterprise Edition）‍‍\n收费，可试用，MySQL提供技术支持。\n\n\n下载地址：https://dev.mysql.com/downloads/ 或者 https://www.mysql.com/ 依次如下点击进行下载。\n\n下拉页面找到download\n\n下载 MySQL Community Server 版（根据自身情况选择）\n\n然后选择对应的版本下载\n\n最后一步可以不用登录和注册。\n\n安装步骤：1、上传下载的安装包到服务器的 &#x2F;usr&#x2F;local 目录下‍\n2、使用 tar 命令解压下载的安装包‍\n tar -xvf mysql-8.0.33-linux-glibc2.12-x86_64.tar.xz参数说明：-x：解压缩压缩档案的参数-v：压缩的过程中显示档案-f：置顶文档名，在f后面立即接文件名，不能再加参数\n\n3、重命名解压后的文件夹\nmv mysql-8.0.33-linux-glibc2.12-x86_64 mysql\n\n4、修改MySQL的配置文件如下\nvim /etc/my.cnf\n# For advice on how to change settings please see# http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html[mysqld]skip-name-resolvecharacter_set_server=utf8init_connect=&#x27;SET NAMES utf8&#x27;## Remove leading # and set to the amount of RAM for the most important data# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.# innodb_buffer_pool_size = 128M## Remove leading # to turn on a very important data integrity option: logging# changes to the binary log between backups.# log_bin## Remove leading # to set options mainly useful for reporting servers.# The server defaults are faster for transactions and fast SELECTs.# Adjust sizes as needed, experiment to find the optimal values.# join_buffer_size = 128M# sort_buffer_size = 2M# read_rnd_buffer_size = 2Mdatadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sock# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid#最大连接数max_connections=1000\n 然后 :wq 退出编辑。‍‍‍‍‍‍‍\n5、新建用户和用户组‍\ncd /usr/local/mysql/groupadd mysql               # 创建用户组useradd -r -g mysql mysql    # 创建用户并且指定用户组chown -R mysql:mysql ./      # 修改当前文件的归属用户和用户组\n\n6、初始化数据库，分别执行如下命令\ncd /usr/local/mysql/mkdir ./data./bin/mysqld --user=mysql --basedir=/usr/local/mysql/ --datadir=/usr/local/mysql/data/ --initialize\n\n第三步命令如果报错：‍‍‍‍.&#x2F;bin&#x2F;mysqld: error while loading shared libraries: libaio.so.1: cannot open shared object file: No such file or directory 的话说明当前缺少了libaio.so.1库，执行如下命令安装libaio.so.1库。\nyum install -y libaio\n\n安装成功后再次执行第三条命令，出现如下界面则说明安装成功了，最后的初始化密码要记住。\n\n7、添加MySQL到系统服务中并且建立软连接‍\ncp -a ./support-files/mysql.server /etc/init.d/mysqlchmod +x /etc/init.d/mysqlchkconfig --add mysqlchkconfig --list mysql #检查是否生效\n\n\n建立软连接\nln -s /usr/local/mysql/bin/mysql /usr/bin\n\n8、启动并且登录MySQL\n执行 service mysql start 命令，出现 Success字样则说明启动成功。 \n\n登录MySQL‍\nmysql -u root -p\n\n\n回车然后输入刚才的初始化密码，输入时光标并不会有任何变化。  \n修改用户密码\nALTER USER &quot;root&quot;@&quot;localhost&quot; IDENTIFIED  BY &quot;你的新密码&quot;;FLUSH PRIVILEGES;  #配置生效\n\n\n修改如下配置，使得root用户可以远程连接。‍‍\nuse mysql;  update user set host=&#x27;%&#x27; where user =&#x27;root&#x27;;FLUSH PRIVILEGES;    #配置生效\n\n​\t\t\n四、MySQL的数据模型关系型数据库（RDBMS）概念：建立在关系型模型基础上，由多张相互连接的二维表组成的数据库。\n特点：&emsp;&emsp; - 1、使用表结构存储。格式统一便于维护。&emsp;&emsp; - 2、使用SQL语言操作，标准统一使用方便。\n\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 七、SQL语言中的约束","url":"/2023/08/01/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E4%B8%83%E3%80%81SQL%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%BA%A6%E6%9D%9F/","content":"1、概念  \n约束是作用于表中字段上的规则，用于限制存储在表中的数据。‍\n2、目的‍\n保证数据库中数据的正确性、有效性和完整性。‍‍‍‍\n3、分类‍\n\n\n\n约束\n描述\n关键字\n\n\n\n非空约束\n限制该字段的数据不能为null\nNOT　NULL\n\n\n唯一约束\n保证该字段所有的值都是唯一不重复的\nUNIQUE\n\n\n主键约束\n主键是一行数据的唯一标识，要求非空且唯一\nPRIMARY KEY\n\n\n默认约束\n保存数据时如果未指定该字段的值则使用默认约束\nDEFAULT\n\n\n检查约束（8.0.16版本之后）\n保证字段值满足某一个条件\nCHECK\n\n\n外键约束\n用来将两张表的数据之间建立连接，保证数据的一致性和完整性\nFOREIGN KEY\n\n\n4、外键约束\n创建外键\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名);\n\n删除外键  \nALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\n\n\n\n5、外键的删除&#x2F;更新行为\n\n\n\n行为\n说明\n\n\n\nNO ACTION\n当在父表中更新&#x2F;删除记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。（与RESTRICT一致）\n\n\nRESTRICT\n当在父表中更新&#x2F;删除记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。（与NO ACTION一致）\n\n\nCASCADE\n当在父表中更新&#x2F;删除记录时，首先检查该记录是否有对应外键，如果有删除&#x2F;更新外键在子表中的记录。（与NO ACTION一致）\n\n\nSET NULL\n当在父表中删除记录时，首先检查该记录是否有对应外键，如果有则将子表中该外键的值置为null。\n\n\nSET　DEFAULT\n父表有变更时，字表将外键列设置为一个默认值。（InnoDB引擎不支持）\n\n\n语法：\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名) ON UPDATE CASCADE ON DELETE CASCADE;","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 三、SQL语言中DML语句的语法","url":"/2023/07/28/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E4%B8%89%E3%80%81SQL%E8%AF%AD%E8%A8%80%E4%B8%ADDML%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%AF%AD%E6%B3%95/","content":"DML：数据操作语言，用来对数据库表中的数据进行增删改操作。\n\n\n添加语句（INSERT）\n给指定字段添加数据：\nINSERT INTO 表名(字段1, 字段2) VALUES(值1, 值2);\n\n给所有的字段添加数据：‍‍‍‍\nINSERT INTO 表名 VALUES(值1, 值2 ... 值n);\n\n批量添加数据：\nINSERT INTO 表名(字段1, 字段2) VALUES(值1, 值2), (值1, 值2)(值1, 值2);\nINSERT INTO 表名 VALUES(值1, 值2 ... 值n), (值1, 值2 ... 值n), (值1, 值2 ... 值n);\n\n添加语句注意的事项：  \n&emsp;&emsp;&emsp;&emsp;1、插入数据时，指定的字段顺序要和值的顺序一一对应。\n&emsp;&emsp;&emsp;&emsp;2、字符串和日期类型应该包裹在引号中。‍‍\n&emsp;&emsp;&emsp;&emsp;3、输入的数据大小应该在字段规定范围内。\n\n\n修改语句（UPDATE）\n修改表中的数据:\nUPDATE 表名 SET 字段1=值1, 字段2=值2 [WHERE 条件];\n\n修改语句的条件没有时会更新整个表的数据。\n\n\n删除语句（DELETE）  \n删除表中的数据:\nDELETE FROM 表名 [WHERE 条件];\n\n删除语句的条件没有时会删除整个表的数据。\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 九、SQL语言中的事物","url":"/2023/08/02/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E4%B9%9D%E3%80%81SQL%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%BA%8B%E7%89%A9/","content":"一、事物的简介‍‍1、什么是事物\n事物是一组操作的集合，它是一个不可分割的工作单元，事物会把所有的操作作为一个整体一起向系统提交或者撤销操作请求，即这些操作要么全部同时成功，要么同时失败。\nMySQL数据库是自动提交事物的。‍‍‍‍\n  \n\n二、事物的操作1、查看、设置事物的提交方式\nSELECT @@AUTOCOMMIT;SET @@AUTOCOMMIT = 0;    (0: 手动提交；1:自动提交)\n\n2、提交事物‍\nCOMMIT;\n\n\n3、回滚事物\nROLLBACK;\n\n4、开启事物\nSTART TRANSACTION;或者BEGIN;\n\n  \n\n三、事物的四大特性 ACID‍‍‍1、原子性（Atomicity）：事物是不可分割的最小操作单元，要么全部成功，要么全部失败。‍‍\n2、一致性（Consistency）：事物完成时，数据的总量保持不变，必须使所有的数据都保持一致的状态。‍\n3、隔离性（Isolation）：数据库提供的隔离机制，保证事物在不受外部并发操作影响的环境下独立运行（A事物的操作不会影响正在进行的B事物）。\n4、持久性（Durability）：事物一旦提交或者回滚，他对数据库中的改变都是永久的。\n\n\n四、并发事物产生的问题‍1、脏读：一个事物读取到了另一个事物没提交的数据。‍‍\n2、不可重复读：一条事物先后执行同样的SQL，但是两次读取的数据不同（同一行数据每次查询不同）。‍‍‍‍‍\n3、幻读：一个事物在执行查询时，每次查询到的数据行数不一致（某一行数据一会存在一会又不存在）。‍\n\n\n五、事物的隔离级别\n\n\n隔离界别\n脏读\n幻读\n不可重复读\n\n\n\nRead Uncommitted\n✔️\n✔️\n✔️\n\n\nRead Committed\n✖️\n✔️\n✔️\n\n\nRepeatable Read\n✖️\n✖️\n✔️\n\n\nSerializable\n✖️\n✖️\n✖️\n\n\n事物的隔离界别越高，数据越安全，但是性能越低。\n查看事物的隔离级别\nSELECT @@TRANSACTION_ISOLATION;\n\n设置事物的隔离级别\nSET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZATION &#125;;","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 二、SQL分类以及DDL语句的语法","url":"/2023/07/28/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E4%BA%8C%E3%80%81SQL%E5%88%86%E7%B1%BB%E4%BB%A5%E5%8F%8ADDL%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%AF%AD%E6%B3%95/","content":"一、SQL的分类‍DDL（Date Definiition Lanhuage）：数据定义语言，用来定义数据库对象（数据库、表、字段等）。 create table 表名;\nDML（Data Manipulation Language）：数据操作语言，用来对数据库中的数据进行增删改查。 alter table 表名 add 字段名 类型(长度);\nDQL（Data Query Language）：数据查询语言，用来查询数据库中表里面的数据。\nselect * from 表名;\n\nDCL（Data Control Language）：数据控住语言，用来创建用户，控制用户对数据库的访问权限。‍\ngrant all privileges on *.* to &#x27;XXX&#x27;@&#x27;%&#x27; identified by &#x27;XXX&#x27; with grant option;\n\n\n\n二、DDL在数据库上的操作查询所有数据库: \nSHOW DATABASES;\n查询当前数据库：  \nSHOW DATABASE();\n 创建数据库：  \nCREATE DATABASE [IF NOT EXISTS] 库名 [DEFAULT CHARSET utf8mb4];\n 删除数据库：‍‍‍‍‍‍‍‍\nDROP DATABASE [IF NOT EXISTS] 库名;\n 使用数据库：\nUSE 库名;\n\n\n\n三、DDL在表上操作查询当前数据库中的所有表：\nSHOW TABLES;\n查询表结构（不会展示字段注释）：  \nDESC 表名;\n查询表的创建语句：\nSHOW CREATE TABLE 表名;\n 创建表：  \ncreate table 表名(    字段1 字段1类型 [comment 字段1注释],    字段2 字段2类型 [comment 字段2注释],    字段3 字段3类型 [comment 字段3注释],    ......    字段n 字段n类型 [comment 字段n注释])[comment 表注释];\n 添加字段：\nALTER TABLE 表名 ADD 字段名 类型(长度);\n 修改字段的数据类型：\nALTER TABLE 表名 MODIFY 字段名 字段类型(长度);\n修改字段的名称和类型：‍‍\nALTER TABLE 表名 CHANGE 旧字段名 新字段名 字段类型(长度);\n 删除字段：\nALTER TABLE 表名 DROP 字段名;\n 修改表名称：\nALTER TABLE 表名 RENAME TO 新表名;\n删除表：‍‍‍‍\nDROP TABLE [IF EXISTS] 表名;TRUNCATE TABLE 表名;\n\nDROP：物理删除表结构加数据。‍‍‍‍TRUNCATE：物理删除表结构加数据后 重新创建表。\n\n\n四、DDL语句中的数据类型1、数值类型  \n\n\n\n类型\n大小\n描述\n\n\n\nTINYINT\n1 bytes\n小整数值\n\n\nSMALLINT\n2 bytes\n大整数值\n\n\nMEDIUMINT\n3 bytes\n大整数值\n\n\nINT 或者 INTEGER\n4 bytes\n大整数值\n\n\nBIGINT\n8 bytes\n极大整数值\n\n\nFLOAT\n4 bytes\n单精度浮点整数\n\n\nDOUBLE\n8 bytes\n双精度浮点整数\n\n\nDECIMAL\n\n小数[精确定点数，依赖于M（精度）和D（标度）]\n\n\n2、字符串类型‍‍‍‍‍‍\n\n\n\n类型\n大小\n描述\n\n\n\nCHAR\n0 - 255 bytes\n定长字符串\n\n\nVARCHAR\n0 - 65536 bytes\n变长字符串\n\n\nTINYBLOG\n0 - 255 bytes\n不超过255个字符的二进制数据\n\n\nTINYTEXT\n0 - 255 bytes\n短文本字符串\n\n\nBLOG\n0 - 65536 bytes\n二进制形式的长文本数据\n\n\nTEXT\n0 - 65536 bytes\n长文本数据\n\n\nMEDIUMBLOG\n0 - 16777215 bytes\n二进制形式的中等长度文本数据\n\n\nMEDIUMTEXT\n0 - 16777215 bytes\n中等长度文本数据\n\n\nLONGBLOG\n0 - 4294967295 bytes\n二进制形式的极大文本数据\n\n\nLONGTEXT\n0 - 4294967295 bytes\n极大文本数据\n\n\n&emsp;&emsp; char(10): 即使存储一个字符，剩下的使用空格占位，效率高。&emsp;&emsp; varchar(10): 存储一个字符，实际占用一个字符，效率低一点。   \n3、日期时间类型\n\n\n\n类型\n大小\n范围\n格式\n描述\n\n\n\nDATE\n3\n1000-01-01 至 9999-12-31\nYYYY-MM-DD\n日期值\n\n\nTIME\n3\n-838:59:59 至 838:59:59\nHH:MM:SS\n时间值或持续时间\n\n\nYEAR\n1\n1901 至 2155\nYYYY\n年份值\n\n\nDATETIME\n8\n1000-01-01 00:00:00 至 9999-12-31 23:59:59\nYYYY-MM-DD HH:MM:SS\n混合日期和时间值\n\n\nTIMESTAMP\n4\n1970-01-01 00:00:01 至 2038-01-19 03:14:07\nYYYY-MM-DD HH:MM:SS\n混合日期和时间值，时间戳\n\n\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 五、SQL语言中DCL语句的语法","url":"/2023/07/28/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E4%BA%94%E3%80%81SQL%E8%AF%AD%E8%A8%80%E4%B8%ADDCL%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%AF%AD%E6%B3%95/","content":"DCL：数据控制语言，用来管理数据库用户、数据库访问权限。\n一、DCL管理用户创建用户\nCRAETE USER &#x27;用户名&#x27;@&#x27;主机&#x27; IDENTIFIED BY &#x27;密码&#x27;;\n\n主机:  localhost:当前主机；%:任意机器。‍‍‍‍‍‍\n查询用户\nSELECT * FROM USER;\n\n修改用户密码  \nALTER USER &#x27;用户名&#x27;@&#x27;主机&#x27; IDENTIFIED WITH mysql_native_password &#x27;密码&#x27;;\n\n删除用户  \nDROP USER &#x27;用户名&#x27;@&#x27;主机&#x27;;\n\n  \n\n二、DCL权限控制‍‍mysql中常用的权限列表‍‍‍‍‍‍‍\n\n\n\n权限\n说明\n\n\n\nALL, ALL PRIVILEGES\n所有权限\n\n\nSELECT\n查询数据\n\n\nINSERT\n插入数据\n\n\nUPDATE\n修改数据\n\n\nDELETE\n删除数据\n\n\nALTER\n修改表\n\n\nDROP\n删除数据库&#x2F;表&#x2F;视图\n\n\nCREATE\n创建数据库&#x2F;表\n\n\n查询权限\nSHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机&#x27;;\n\n授予权限  \nGRANT 权限列表 ON 数据库.表名 TO &#x27;用户名&#x27;@&#x27;主机&#x27;;\n\n撤销权限  \nREVOKE 权限列表 ON 数据库.表名 FROM &#x27;用户名&#x27;@&#x27;主机&#x27;;\n\n‍‍‍\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 八、SQL语言中的多表关系","url":"/2023/08/02/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%85%AB%E3%80%81SQL%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A4%9A%E8%A1%A8%E5%85%B3%E7%B3%BB/","content":"笛卡尔积：笛卡尔积是指在数学中，两个集合A集合和B集合的所有组合情况（多表查询时需要消除无效的笛卡尔积）。\n多表查询的分类1、内连接（C表示部分）\n\n隐式内连接    SELECT * FROM 表1, 表2 WHERE 条件;显示外连接    SELECT * FROM 表1 [INNER]JOIN 表2 ON 条件;\n\n2、外连接\n\n左外连接表示A和C部分\nSELECT 字段 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件;\n\n右外连接表示B和C部分  \nSELECT 字段 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件;\n\n3、自连接\nSELECT 字段 FROM 表A 别名A JOIN 表A 别名B ON 条件;\n\n4、联合查询‍\n    多次查询的结果合并起来，形成一个新的查询结果集。多张表的列数和类型需要保持一致。\nSELECT 字段列表 FROM 表A...UNION [ALL] SELECT 字段列表 FROM 表B...\n\nUNION: 查询结果去重‍\nUNION ALL: 查询结果不会去重‍‍‍‍‍‍‍‍‍\n4、子查询\nSQL语句中嵌套SELECT语句，称为嵌套语句，又称子查询。‍‍‍‍\nSELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 六、SQL语言中函数","url":"/2023/08/01/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%85%AD%E3%80%81SQL%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%87%BD%E6%95%B0/","content":"函数：是指一段可以直接被另一段程序调用的程序或代码。\n一、字符串函数\n\n\n函数\n功能\n\n\n\nCONCAT(S1, S2, …, Sn)\n字符串拼接，将字符串S1，S2…Sn拼接成一个新字符串\n\n\nLOWER(str)\n将字符串str全部转为小写\n\n\nUPPER(str)\n将字符串str全部转为大写\n\n\nLPAD(str, n, pad)\n左填充，用字符串pad对str的左边进行填充，达到n个字段的长度\n\n\nRPAD(str, n, pad)\n右填充，用字符串pad对str的右边进行填充，达到n个字段的长度\n\n\nTRIM(str)\n去掉字符串头部和尾部的空格\n\n\nSUBSTRING(str, start, len)\n返回字符串str从start开始起的len个长度的字符串\n\n\n1、CONCAT函数\nSELECT CONCAT(&#x27;hello&#x27;, &#x27;mysql&#x27;);输出：hello mysql\n\n2、LOWER函数‍‍\nSELECT LOWER(&#x27;HELLO&#x27;);输出：hello\n\n3、UPPER函数\nSELECT UPPER(&#x27;hello&#x27;);输出：HELLO\n\n4、LPAD函数  \nSELECT LPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);输出：---01\n\n5、RPAD函数\nSELECT RPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);输出：01---\n\n6、TRIM函数（只能去除两端的空格，不能去除中间的空格）\nSELECT TRIM(&#x27; Hello Trim &#x27;);输出：Hello Trim\n\n7、SUBSTRING\nSELECT SUBSTRING(&#x27;Hello MySQL&#x27;, 1, 5);输出：Hello\n\n  \n\n二、数值函数‍‍\n\n\n函数\n功能\n\n\n\nCEIL(x)\n向上取整\n\n\nFLOOR(x)\n向下取整\n\n\nMOD(x, y)\n返回x&#x2F;y的模\n\n\nRAND()\n返回0～1内的随机数\n\n\nROUND(x, y)\n求参数x的四舍五入的值，保留y位小数\n\n\n1、CEIL函数\nSELECT CEIL(1.6);    输出：1SELECT CEIL(1.1);    输出：1\n\n2、FLOOR函数\nSELECT FLOOR(1.6);    输出：2SELECT FLOOR(1.1);   输出：2\n\n3、MOD函数(求余数)  \nSELECT MOD(3, 4);   输出：3SELECT MOD(6, 4);    输出：2\n\n4、RAND  \nSELECT RAND();       输出：0～1之间的随机数\n\n5、ROUND‍\nSELECT ROUND(2.34, 2);     输出：2.34SELECT ROUND(1.236, 2);    输出：1.24\n\n  \n\n三、日期函数‍‍‍‍\n\n\n函数\n功能\n\n\n\nCURDATE()\n返回当前日期\n\n\nCURTIME()\n返回当前时间\n\n\nNOW()\n返回当前日期和时间\n\n\nYEAR(date)\n返回执行date的年份\n\n\nMONTH(date)\n返回指定date的月份\n\n\nDAY(date)\n返回指定date的日期\n\n\nDATE_ADD(date, INTERVAL expr type)\n返回一个日期&#x2F;时间加上一个时间间隔expr后的时间值\n\n\nDATEDIFF(date1, date2)\n返回起始时间date1和结束时间date2之间的天数\n\n\n1、CURDATE\nSELECT CURDATE();    输出：2023-07-13\n\n2、CURTIME\nSELECT CURTIME();    输出：08:37:26\n\n3、NOW\nSELECT NOW();        输出：2023-07-13 08:38:33\n\n4、YEAR、MONTH、DAY\nSELECT YEAR(NOW());      输出：2023SELECT YEAR(MONTH());    输出：7SELECT YEAR(DAY());      输出：13\n\n5、DATE_ADD\nSELECT DATE_ADD(NOW(), INTERVAL 70 DAY);输出：2023-09-21 08:40:13SELECT DATE_ADD(NOW(), INTERVAL -10 MONTH);输出：2022-09-13 08:40:13\n\n6、DATEDIFF(第一个时间减第二个时间)\nSELECT DATEDIFF(&#x27;2023-07-10&#x27;, &#x27;2023-07-01&#x27;);输出：9\n\n  \n\n四、流程控制函数‍‍\n\n\n函数\n功能\n\n\n\nIF(value, t, f)\n如果value为true则返回t，否则返回f。\n\n\nIFNULL(val1, val2)\n如果val1不为空则返回val1，否则返回val2。\n\n\nCASE WHEN [val1] THEN [res1] … ELSE [default] END\n如果val1为true则返回res1…否则返回默认值default。\n\n\nCASE [expr] WHEN [val1] THEN [res1] … ELSE [default] END\n如果表达式expr的值为val1则返回res1…否则返回默认值default。\n\n\n1、IF\nSELECT IF(true, &#x27;OK&#x27;, &#x27;Error&#x27;);    输出：OK\n\n2、IFNULL‍\nSELECT IFNULL(&#x27;OK&#x27;, &#x27;Default&#x27;);    输出：OKSELECT IFNULL(&#x27;&#x27;, &#x27;Default&#x27;);      输出：SELECT IFNULL(NULL, &#x27;Default&#x27;);    输出：Default\n\n3、CASE WHEN THEN ELSE END\n查询员工姓名和城市，如果城市是上海和北京返回一线城市，其他返回二线城市SELECT \tname, \tCASE work_address WHEN &#x27;上海&#x27; THEN &#x27;一线&#x27; WHEN &#x27;北京&#x27; THEN &#x27;一线&#x27; ELSE &#x27;二线&#x27; END FROM worker;","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 十、数据库中的存储引擎","url":"/2023/08/02/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%8D%81%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/","content":"一、MySQL的体系结构‍\n连接层：最上层是一些客户端和链接服务，主要完成一些连接处理、授权认证以及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具备的操作权限。‍\n服务层：主要完成大多数的核心功能，如SQL接口，并完成查询的缓存，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能在这一层实现，如存储过程和视图等。‍‍‍‍‍‍‍‍‍\n引擎层：存储引擎真正的负责了MYSQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样就可以根据自己的需要来选择合适的存储引擎。‍\n存储层：主要是将数据存储在文件系统之上并完成与存储引擎的交互。‍‍‍‍\n  \n\n二、存储引擎的简介1、什么是存储引擎‍‍‍\n存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表而非基于库的，所以存储引擎也可被称为表类型。‍‍‍‍\n2、查看数据库支持的存储引擎‍‍\nSHOW ENGINES;\n\n\n3、查看已创建表的存储引擎‍\nSHOW CREATE TABLE tb_wxuser;\n\n\n\n\n三、常见的存储引擎1、InnoDB存储引擎：InnoDB是一种兼顾可靠性和高性能的通用存储引擎，在MySQL5.5之后InnoDB是默认的存储引擎。\nInnoDB的特点：\n（1）、DML遵循ACID模型，支持事物。‍\n（2）、支持行及锁，提高并发访问性能。‍‍‍‍\n（3）、支持外键FOREIGN KEY约束，保证数据的完整性和正确性。‍‍‍\nInnoDB的文件存储：\nXXX.ibd:XXX代表的是数据库的表名，InnoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm，sdi）、数据和索引。‍‍‍\n参数：innodb_file_per_table &#x3D; ON 表示每一个表对应一个ibd存储文件，OFF表示共用一个ibd存储文件。‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍\nInnoDB的存储结构：\n\n2、MyISAM存储引擎：MyISAM是MySQL早期的默认存储引擎。\nMyISAM引擎特点：  \n（1）：不支持事物、不支持外键。\n（2）：支持表锁但不支持行锁。\n（3）：访问速度较快。  \nMyISAM引擎的文件存储：\n\n3、Memory存储引擎：Memory引擎的表数据存储在内存中，容易受到硬件问题、断电等的影响，因此只能将这些表作为临时表或者缓存使用。\nMemory引擎特点：\n（1）、内存存放数据 。\n（2）、默认hash索引。\nMemory引擎文件存储：\nxxx.sdi: 存储表结构信息\n4、innoDB、MyISAM、Memory三者的区别\n\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 十一、数据库中的索引","url":"/2023/08/02/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%8D%81%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95/","content":"一、索引概述什么是索引‍‍?\n索引（index）是帮助MySQL高效获取数据的有序数据结构。在数据之外，数据库还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构之上实现高级查找算法，这种数据结构就是索引。‍‍‍‍‍‍‍‍\n索引的优点‍‍\n    1、提高了检索数据的效率。\n    2、通过索引列对数据进行排序，降低数据的排序成本。\n索引的缺点：\n    1、索引也要占用空间。\n    2、索引提高了查询效率的同时也降低了更新数据（INSERT、UPDATE…）的效率。‍‍‍‍‍‍\n\n\n二、索引的语法创建索引\nCREATE [UNIQUE | FULLTEXT | ] INDEX index_name ON table_name(index_col_name, ...);\n\n查看索引\nSHOW INDEX FROM table_name;\n\n删除索引\nDROP INDEX index_name ON table_name;\n\n\n三、索引结构MySQL的索引是在引擎层实现的，不同的存储引擎有不同的结构，主要包括下面几种：‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍\n\n\n\n索引结构\n描述\n\n\n\nB+Tree索引\n最常见的索引类型，大部分引擎都支持B+树索引。\n\n\nHash索引\n底层使用hash表实现的索引，不支持范围查询，只有精确匹配的列才有效。\n\n\nR-tree索引（空间索引）\n空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少。\n\n\nFull-text（全文索引）\n是一种通过建立倒排索引，快速匹配文档的方式。类似于Lucene，Solr，ES。\n\n\n不同的索引在各个存储引擎中的支持情况：\n\n\n\n索引\nInnoDB\nMyISAM\nMemory\n\n\n\nB+Tree索引\n支持\n支持\n支持\n\n\nHash索引\n不支持\n不支持\n支持\n\n\nR-tree索引\n不支持\n支持\n不支持\n\n\nFull-text（全文索引）\n5.6版本之后支持\n支持\n不支持\n\n\n数据结构在线模拟：https://www.cs.usfca.edu/~galles/visualization/Algorithms.html\n1、Btree和Btree索引\n二叉树（大于祖先节点在右侧，小于祖先节点在左侧）\n\n二叉树的缺点‍‍‍\n(1)、顺序插入时会形成一个链表，查询性能大大降低。(2)、数据量较大的情况下层级较深，检索速度慢。‍‍‍‍‍‍‍‍‍‍‍\n红黑树（自平衡的二叉树）‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍\n\n红黑树的缺点：数据量较大的情况下层级较深，检索速度慢。\nB树（多路平衡二叉树）\n以一颗最大度数（max-degree）为5（5阶）的b-tree为例（每个节点最多可存储4个可以，5个指针）。‍‍\n树的度数指得是一个节点的子节点的个数。\n\n2、B+树和B+树索引‍‍‍‍\n以一棵最大度数为4的b+为例‍‍‍‍‍\n\n（1）、所有的数据都会在叶子结点出现\n（2）、叶子结点会形成一个单向列表\nMySQL中的B+树\n\nMySQL数据结构对经典的B+树进行了优化。在原有B+树基础之上增加了一个只下过相邻叶子结点的链表指针，就形成了带有顺序指针的B+树，提高了区间访问的性能。  \n3、hash索引\n采用一定的hash算法，将键值转换成新的hash值，映射到对应到槽位上，然后存储到hash表中。‍‍‍‍‍‍‍‍\n如果两个（或多个）键值映射到同一个槽位上，他们就产生了hash冲突（也成hash碰撞），hash冲突可以通过链表来解决。‍\n‍\nHash索引的特点：\n（1）、hash索引只能用于对等比较（&#x3D;，in），不支持范围查询（between，&lt;， &gt;）。‍‍\n（2）、无法利用索引完成排序。‍\n（3）、查询效率高，通常只需要一次检索即可（hash冲突时会去查询链表），效率高于B+tree索引。‍‍‍‍‍\n思考：为什么InnoDB索引选择B+树而非二叉树或者红黑树或者B树？‍‍‍‍‍‍\n如果是顺序插入的话，二叉树会形成链表，导致树的层级较深，从而降低查找的效率，红黑树本质也是二叉树，也会有该问题。相对于二叉树，B+树层级更少，效率更高。‍‍‍‍‍‍‍\nB树非叶子结点也会存储数据，导致磁盘页上存放的数据变少，相同数据量的情况下，树的高度会增加，导致效率降低。B+树的叶子节点为双向链表，便于范围查询和排序。‍‍‍‍‍\nHash索引不支持范围查询和排序。‍‍‍‍‍\n  \n\n四、索引分类\n\n\n分类\n含义\n特点\n关键字\n\n\n\n主键索引\n针对于表中主键创建的索引\n默认自动创建，只有一个。\nPRIMARY\n\n\n唯一索引\n避免同一表中某数据列的值重复\n可以有多个\nUNIQUE\n\n\n常规索引\n快速定位特定数据\n可以有多个\n\n\n\n全文索引\n全文索引查找的是文本中的关键词，而不是比较索引中的值。\n可以有多个\nFULLTEXT\n\n\n在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：\n\n\n\n分类\n含义\n特点\n\n\n\n聚集索引（Clustered Index）\n将数据存储与索引放在了一起，索引结构的叶子结点保存了行数据。\n必须有，而且只有一个。\n\n\n二级索引（Secondary Index）\n将数据与索引分开存储，索引结构的叶子结点关联的是对应的主键。\n可以存在多个。\n\n\n聚集索引的选取规则：‍‍‍‍‍‍‍‍\n    1、如果存在主键，主键就是聚集索引。\n    2、如果不存在主键，将使用第一个唯一索引作为聚集索引。\n    3、如果表没有主键或者没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。‍‍\n聚集索引和二级索引的图示‍‍\n\n聚集索引叶子节点存储的是每一行的数据（row），二级索引每一个叶子结点存储的是对应行的id。  \n聚集索引和二级索引在查询中的执行过程：‍‍‍\n\n1、首先执行where条件后的查询，使用二级索引根据name拿到id。\n2、根据id到聚集索引查询行数据。（回表查询）\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 十三、SQL性能优化","url":"/2023/08/25/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%8D%81%E4%B8%89%E3%80%81SQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","content":"一、插入数据优化批量插入单条数据频繁的插入会存在大量的IO和不停的与数据库建立连接。批量插入的数据建议在500～1000条，更多的话建议使用多个批量插入。手动提交事物MySQL默认的是自动提交事物，多条插入语句时会频繁的开启、提交事物。\n\nstart transaction;insert into tb_user values(1, ‘tom’),(2, ‘jerry’),(3, ‘lacy’);insert into tb_user values(1, ‘tom’),(2, ‘jerry’),(3, ‘lacy’);insert into tb_user values(1, ‘tom’),(2, ‘jerry’),(3, ‘lacy’);commit;\n\n主键按顺序插入\n\n主键乱序插入 8 2 5 98 2 56 121 1 4 22主键顺序插入 2 3 7 23 46 144 145 400\n\n大批量数据插入如果一次性需要插入大量的数据，使用insert语句插入数据性能较低，此时可以使用MySQL数据库提供的load指令进行插入。\n\n#客户端连接服务器端时，加上参数 –local-infilemysql –local-infile -u root -p#设置全局参数local_infile为1，开启从本地加载文件导入数据的开关。set global local_infile &#x3D; 1;#执行load指令将准备好的数据加载到表结构中load data local iinfile ‘数据文件路径’ into table 表名 fields terminated by ‘,’ lines terminated by ‘\\n’;\n\n二、主键优化数据组织方式在innoDB存储引擎中，表中数据都是根据主键顺序存放的，这种存储方式的表称为索引组织表（index orgnized tab）IOT。页合并当删除一行数据时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录生声明使用。当页中删除的纪录达到MERGE_THRESHOLD（默认为页的50%），InnoDB就开始寻找最靠近的页（前或后）看看是否可以讲两个页合并以优化空间的使用。MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引的时候指定。主键设计原则1、满足业务需求的情况下，尽量降低主键的长度，因为二级索引存储的数据就是主键。2、插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。3、尽量不要使用UUID（会产生页分裂以及UUID长度较大，长度较大时加大了二级索引的大小，降低了查询效率）或其他自然主键，如身份证号。4、业务操作时避免对主键的修改。\n三、order by 优化两种排序方式：\n\nUseing filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫FileSort排序。\n\nUseing index：通过有序索引顺序扫描直接返回有序数据，这种情况即为useing index，不需要额外排序，操作效率高。\n\n\n执行如下SQL：select id, age, phone from tb_user order by age, phone;，会产生FileSort排序。对表tb_user创建如下索引：create index inx_user_age_phone on tb_user(age, phone);，再次执行上述查询，FileSort消失，转而使用索引排序，提高了查询效率。\n紧接着再次执行如下查询：select id, age, phone from tb_user order by age asc, phone desc;，会发现分别使用了索引排序和文件内排序，这是因为创建索引时默认字段为升序排列，再创建一个索引create index inx_user_age_phone on tb_user(age asc, phone desc);，执行查询语句：select id, age, phone from tb_user order by age asc, phone desc;，会发现使用了索引。\nOrder By优化原则\n1、根据排序字段建立合适的索引，多字段排序时也遵循最左前缀法则。\n2、尽量使用覆盖索引。\n3、多个字段排序，有的升序有的降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）。\n4、如果避免不了FileSort，大数据量排序时，可以适当增加排序缓冲区的大小sort_buffer_size(默认256k)。\nSHOW VARIABLES LIKE &#x27;sort_buffer_size&#x27;;\n\n\n四、group by 优化1、分组操作时可以通过索引来提高效率。\n2、分组操作时，索引的使用也得满足最左前缀法则。\n五、limit优化一个常见有非常头疼的问题是limit 2000000,10，此时MySQL排序前2000010条记录，仅仅返回2000000～2000010的记录，其他的记录则舍弃，查询时排序代价非常大。\n优化思路：一般分页查询时，通过创建覆盖索引能够比较好的提高性能，可以通过覆盖索引加子查询形式进行优化。\nexplain select * from tb_sku s, (select id from tb_sku order by id limit 2000000,10) a where a.id = s.id;\n\n\n六、count优化explain select count(*) from tb_user;\n\n\nMyISAM引擎把一个表的总行数存放在磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高。\nInnoDB引擎执行count(*)的时候，需要把数据一行一行的从引擎里面读取出来，然后累计计数。\n\n优化思路：目前针对count并没有特别好的优化方式，可以自己在内存中维护一个计数器。\ncount的几种用法：\n\ncount(主键)\nInnoDB引擎会遍历整张表，把每一行的主键id都取出来返回给服务层，服务层拿到主键后，直接按行进行累加（主键不会为null）。\n\ncount(字段)\n没有not null 约束：InnoDB引擎会遍历整张表的每一行数据然后返回给服务层，服务层再判断是否为null，不为null时计数加1。\n有not null约束：InnoDB引擎会遍历整张表的每一行数据然后返回给服务层，服务层进行按行累加。\n\ncount(1)\nInnoDB遍历整张表但不取值，服务层对于返回的每一行都放一个数字“1”进去，直接按行进行累加。\n\ncount(*)\nInnoDB并不会把全部字段取出来，而是专门做了优化，服务层直接按行进行累加。\n\n\n按照效率排序：count(*) ≈ count(1) &gt; count(主键) &gt; count(字段) ，尽量使用count(*)。\n七、update优化（避免行锁升级为表锁）update tb_user set name = &#x27;zhang&#x27; where id = 1;\n\n此时为行锁，对并发无影响。\nupdate tb_user set name = &#x27;li&#x27; where id = 2;\n\n如果name字段无有效的索引，此时将会把整个表锁住。\nInnoDB的行锁是针对索引加的锁（索引不能失效），不知针对记录加的锁，索引失效或者无索引的情况下会将行锁升级为表锁。\nupdate尽量使用主键进行更新。\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 十二、SQL性能分析和索引使用原则","url":"/2023/08/07/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%8D%81%E4%BA%8C%E3%80%81SQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99/","content":"一、查看SQL的执行频率通过SQL的执行频率可以确定当前数据库执行哪类操作比较多，然后做出对应的优化措施。\n通过如下命令可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT等操作的执行频次。\nSHOW GLOBAL STATUS LIKE &#x27;Com_______&#x27;\n\n\n\n\n二、慢查询日志慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。\nMySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：\n# 开启MySQL的慢日志查询开关slow_query_log=1# 设置慢日志的查询时间，SQL语句执行时间超过指定的值(如下超过10秒则为慢查询)，则会视为慢查询，记录慢查询日志。long_query_time=10\n\n配置完毕以后需重启MySQL服务，慢日志信息记录在文件：/var/lib/mysql/localhost-show.log中。\n查询慢日志查询是否开启，如下命令：\nSHOW VARIABLES like &#x27;slow_query_log&#x27;;\n\n输出Value值为：ON 则说明慢日志查询开启。\n\n\n三、show profiles命令在实际的业务中，有些SQL查询比较简单，但是查询占用的时间刚好小于慢日志记录设置的时间，导致这类慢SQL不能被捕捉到。\nshow profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够查看到当前MySQL是否支持profile操纵。\nSELECT @@have_profiling;\n\n输出值为：YES则说明当前数据库支持profile。\n默认profile是关闭的，可以通过命令开启GLOBAL或者SESSION级别的profiling。\nSET [GLOBAL | SESSION] profiling = 1;\n\nprofile相关的一些命令\n# 查看每一条SQL的耗时基本情况show profiles;# 查看指定query的SQL语句的各个阶段的耗时情况,query_id:上一步的idshow profile for query [query_id];# 查看指定SQL的CPU占用情况show profile cpu for query [query_id];\n\n\n\n四、explain命令EXPLAIN或者DESC命令用来获取MySQL是如何执行SELECT语句的信息，包括SELECT语句执行过程中表如何连接和连接顺序等信息。\n语法\n# 直接在select语句前面加上关键字 explain/descEXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;\n\nEXPLAIN展示的各个字段的含义：\n\n\n\n字段名\n含义\n\n\n\nid\n查询的序列号，表示查询中执行select字句或者是操作表的顺序。（id越大越先被执行，id相同时按照从上往下的顺序执行查询）\n\n\nselect_type\n表示select的类型，常见的取值有SIMPLE（简单表，即不使用表链接或者子查询）、PRIMARY（主查询，即外层查询）、UNION（UNION中的第二个或者后面的查询）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等。\n\n\ntype\n表示连接类型，性能由好到差为NULL、SYSTEM、CONST、EQ_REF、REF、RANGE、INDEX、ALL。\n\n\npossible_key\n显示可能用在这张表上的索引，一个或者多个。\n\n\nkey\n实际使用的索引，没有则为NULL。\n\n\nkey_length\n表示索引使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精度的情况下，长度越短越好。\n\n\nrows\nMySQL认为必须要执行查询的行数，在InnoDB引擎中是一个估算值，可能并不总是准确的。\n\n\nfiltered\n表示返回结果的行数占需要读取行数的百分比，filtered的值越大越好。\n\n\nextra\n额外信息\n\n\nextra中显示的信息，MySQL版本不通则显示的不同。\n五、索引的使用规则以及失效场景最左前缀法则：如果索引了多列（联合索引），要遵守最佳左前缀法则。最左前缀法则是指查询从索引的最左列开始，并且不跳过索引中的列。如果跳过了索引中的某一列，索引将部分失效（跳过列后方的字段索引失效）；\n\nwhere条件后面列的顺序可以和索引中定义的顺序不一致。\n\nSQL提示：是优化数据库的一个重要手段，简单来说就是在SQL语句中加入一些人为的提示来达到优化操作的目的。\n\nuse index;  告诉数据库你应该使用哪一个索引（建议使用）\nSELECT 字段列表 FROM 表名 use index(index_name) WHERE 条件;\n\n\nignore index;  告诉数据库你不要使用哪一个索引\nSELECT 字段列表 FROM 表名 ignore index(index_name) WHERE 条件;\n\n\nforce index;  告诉数据库你必须要使用哪一个索引（强制使用）\nSELECT 字段列表 FROM 表名 force index(index_name) WHERE 条件;\n\n覆盖索引：尽量使用覆盖索引（查询使用了索引，并且查询的字段全部可以在索引中找到），避免使用SELECT *（极易出现回表查询）。\n\n现有如下表结构，分别对主键ID和字段name建立索引：\n\n\n\n\nID\nNAME\nGENDER\nCREATEDATE\n\n\n\n2\nArm\n1\n2023-08-22\n\n\n4\nLily\n1\n2023-08-01\n\n\n5\nRosy\n0\n2023-03-10\n\n\n8\nZoom\n1\n2023-11-09\n\n\n\n聚集索引（id）：\n\n\n\n辅助索引（name）：\n\n\n\n分别进行以下查询：\n\nSELECT * FROM tb_stu WHERE id = 2;走聚集索引，一次就可查询出数据。SELECT id, name FROM tb_stu WHERE name = &#x27;Arm&#x27;;走辅助索引即可查询出需要的所有数据（覆盖索引）。SELECT id, name, gender FROM tb_stu WHERE name = &#x27;Arm&#x27;;首先根据辅助索引查询，只能查询出name和id字段，然后再使用id字段去聚集索引中查询gender字段（回表查询）。\n\n\n思考：一张表有四个字段（id, name, password, status），由于数据量较大需要对以下SQL进行优化，该如何进行才是最优方案？\nSELECT id, name, password, status FROM tb_user WHERE name = &#x27;Tom&#x27;;\n\n方案1: 为字段name建立索引。\n如果只为name字段建立索引的话，查询回进行两次，首先走辅助索引查询出name和id，然后再使用主键索引根据id查询password和status字段，涉及到了回表操作。\n方案2: 为字段name和password以及status字段建立索引。\n此时where条件会使用建立的索引（最佳左前缀），并且根据索引就能查询出需要的数据，不需要回表等操作，因此性能最高。\n\n前缀索引：当字段类型为字符串（varchar，text）时，有时候需要索引很长的字符串（比如博客中的内容），只会让索引变得很大，查询时会浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀建立索引，这样可以大大减少索引空间进而提示查询效率。\n语法：\nCREATE INDEX index_name ON table_name(column(n));\t-- n:前缀长度\n\n如何决定前缀的长度：可以根据前缀的选择性来决定，而前缀的选择性是指不重复的索引值（基数）和数据总量的比值，选择性越高则查询效率越高，唯一索引的选择性为1，是最好的选择性，性能也是最高的。\n选择行计算：SELECT count (distinct email)/count(*) FROM tb_user;\t                -- 1SELECT count (distinct substring(email,1,4))/ count(*) FROM tb_user;\t-- 0.9876\n\n范围查询：联合索引中，出现范围查询（&gt;, &lt;）时，范围查询右侧的索引将失效。\n\n大于等于, 小于等于 不会使得索引失效，因此在业务允许的情况下尽量使用大于等于代替大于，用小于等于代替小于。\n\n索引列上运算：在索引列上进行计算操作将导致索引失效。\n字符串不加引号：使用字符串列时不加引号会导致索引失效（隐式转换）。\n模糊查询：如果仅是尾部进行模糊匹配索引不会失效，如果是头部进行模糊匹配则会失效。\n\nWHERE name like ‘%张三’；\t索引失效\nWHERE name like ‘张三%’；\t索引有效\n\nOR连接的条件：用or分隔开的条件，如果or前面的条件中的列有索引，而后面的列中没有索引，那么涉及到的索引都不会生效。or前后的条件都有索引时会生效。\n数据分布影响：如果MySQL评估使用索引比全表更慢时则不会使用索引。\n如果使用索引查出的数据量大于全表的数据量的1&#x2F;2，MySQL会使用全表扫描。\n\n对字段使用not null或者is not null时，MySQL也会评估是走索引还是全表扫描。\n\n\n\n六、索引的设计规则\n针对数据量较大且查询比较频繁的表建立索引。\n\n针对常作为查询条件（where）、排序（order）、分组（group by）操作的字段建立索引。\n\n尽量选择区分度较大的列作为索引，尽量选择唯一索引，区分度越高，使用索引的效率越高。\n\n如果是字符串类型的字段并且字段的长度较长，可以针对字段的特点建立前缀索引。\n\n尽量使用联合索引，减少单列索引，查询时联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。\n\n控制索引的数量，索引并不是越多越好，索引越多，维护索引的成本就越高，增删改的效率也会被影响。\n\n如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好的确定哪一个索引可最有效的用于查询。\n\n\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 十五、MySQL中的锁","url":"/2023/08/30/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%8D%81%E4%BA%94%E3%80%81MySQL%E4%B8%AD%E7%9A%84%E9%94%81/","content":"一、锁的基本介绍介绍锁是计算机协调多个进程或者线程并发访问某一资源的机制，在数据库中，除了传统的计算资源（CPU、RAM、IO）争用外，数据也是一种供多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。分类MySQL中的锁，按照锁的粒度分为以下三类：1.全局锁：锁定数据库中的所有表2.表级锁：每次操作锁住整张表3.行级锁：每次操作锁住对应的行\n\n\n二、全局锁介绍全局锁就是对整个数据库实例开锁，加锁后整个实例处于只读状态，后续的DML的写语句，DDL语句，已经更新的操作的事物的提交语句都将被阻塞。最典型的使用场景就是全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。语法创建全局锁\nflush tables with read lock;\n解除全局锁\nunloak tables;\n数据库实例备份\nmysqldump -h 主机地址 -u用户名 -p密码 数据库实例名 &gt; 备份文件.sql\n特点数据库中的全局锁是一个比较重的操作，会存在以下问题：1.如果在主库上执行备份，那么备份期间都不能执行更新，整个业务停摆。2.如果在从库上备份，那么备份期间从库不能执行主库同步过来的二进制日志（binlog），导致主从延迟。在InnoDB引擎中，我们可以在备份时加行参数--single-transaction参数来完成不加锁的一致性数据备份。\nmysqldump --single-transaction -h 主机地址 -u用户名 -p密码 数据库实例名 &gt; 备份文件.sql\n\n三、表级锁介绍表级锁，每次操作都会锁住整张表。锁定力度大，发生锁冲突的概率高，并发度支持较低。应用在MyISAM，InnoDB，BDB等存储引擎中。对于表级锁，主要分为一下三类：    1.表锁    2.元数据锁（Meta Data Locl）MDL    3.意向锁表锁对于表锁，分为两类    1.表共享读锁（read lock）session1对表A加read lock，此时session1可以对表A执行查询操作但是不能执行修改操作，session2可以对表A执行查询操作但是不能执行修改操作。    2.表独占写锁（write lock）session1对表A加write lock，此时session1可以对表A执行查询操作和修改操作，session2即不能对表A执行查询操作页不能执行修改操作。语法1.加锁 lock tables 表名... read/write2.解锁 unlock tables / 断开客户端连接特点读锁不回阻塞客户端的读操作，但是会阻塞写操作。写锁会阻塞其他客户端的读写但不回阻塞当前加锁客户端的读写。元数据锁MDL加锁过程是系统自动控制的，无需显示调用，在访问一张表的时候会自动加上，MDL锁的作用是维护元数据的数据一致性，在表上有活动事物的时候，不可以对元数据进行写入操作。为了避免DML和DDL的冲突，保证读写的正确性。在MySQL5.5中引入了MDL，当对一张表进行增删改操作的时候，加MDL读锁（共享）；当对一张表进行结构变更操作的时候，加MDL写锁（排他）。\n\n\n\n对应SQL\n锁类型\n说明\n\n\n\nlock table xxx read&#x2F;write\nSHARE_READ_ONLY、SHARE_NO_READ_WRITE\n\n\n\nselect、select … lock in share mode\nSHARE_READ\n与SHARE_READ、SHARE_WRITE兼容，与EXCLUSIVE互斥\n\n\nInsert、update、delete、select … for update\nSHARE_WRITE\n与SHARE_READ、SHARE_WRITE兼容，与EXCLUSIVE互斥\n\n\nalter table …\nEXCLUSIVE\n与其他的MDL锁互斥\n\n\n意向锁为了避免DML在执行时，加的行锁和表锁出现冲突，在InnoDB中引入了意向锁，使得表锁不用检查每一行的数据是否加锁，使用意向锁来减少表锁的检查，从而提高效率。意向锁的分类：    1.意向共享锁（IS）：由语句 select ... lock in share mode; 添加，与表锁共享锁（read）兼容，与表锁排它锁（write）互斥。    2.意向排他锁（IX）：由语句 insert、update、delete、select ... for update 添加，与表锁共享锁（read）和排它锁（write）互斥，意向锁之间不回互斥。\n查看意向锁的加锁情况\nselect object_schema, object_name, index_name, lock_type, lock_data, lock_mode, lock_status from performance_schema.data_locks;\n行级锁每次操作都会锁住对应的行数据，锁的粒度最小，发生锁冲突的概率较低，并发度最高，应用在innoDB引擎中。行锁的分类：    InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项来加锁实现的，并不是对记录加锁。对于行级锁，主要分为以下三类：    1.行锁（Record Lock）：锁订单个行的记录到的锁，防止其他事物对该行数据进行update、delete等操作，在RC、RR隔离模式下都支持。    2.间隙锁（Gap Lock）：锁定索引记录间隙，确保索引记录间隙不变，防止其他事物在这个间隙insert，从而引起幻读，在RR模式下都支持。    3.临键锁（Next-key Lock）：行锁和间隙锁的组合，锁住数据的同时锁住数据前面的间隙（Gap），在RR模式下都支持。\nInnoDB实现了两种类型的行锁：    1.共享锁（S）：允许一个事物去读取一行，阻止其他事物获取相同数据集的排它锁。（当前事物读取数据时其他事物可以读取该行数据但是不能修改）    2.排它锁（X）：允许获取排它锁的事物更新数据，阻止其他事物获取相同数据集的共享锁和排它锁。（当前事物修改数据时，其他事物不能读取、不能修改当前行数据）\n\n\n\n锁类型\nS（共享锁）\nX（排它锁）\n\n\n\nS（共享锁）\n兼容\n冲突\n\n\nX（排它锁）\n冲突\n冲突\n\n\n常见的sql语句对行数据的加锁情况\n\n\n\nSQL\n行锁类型\n说明\n\n\n\nINSERT …\n排它锁\n自动加锁\n\n\nUPDATE …\n排它锁\n自动加锁\n\n\nDELETE …\n排它锁\n自动加锁\n\n\nSELECT (正常查询)\n不加任何锁\n\n\n\nSELECT … LOCK IN SHARE MODE\n共享锁\n手动在sql后面添加LOCK IN SHARE MODE\n\n\nSELECT … FOR UPDATE\n排它锁\n手动在sql后面添加FOR UPDATE\n\n\n\nInnoDB的行锁是针对索引添加的锁，不通过索引检索数据时，InnoDB将对表中的所有记录加锁，此时行锁升级为表锁\n\n现在有一张用户表，表结构如下：\ncreate table t_user_base_info(    id            varchar(32)      not null comment &#x27;id&#x27; primary key,    login_account varchar(50)      not null comment &#x27;登陆账号&#x27;,    password      varchar(50)      not null comment &#x27;登陆密码&#x27;,    username      varchar(255)     not null comment &#x27;用户名&#x27;,    user_type     int(2) default 1 not null comment &#x27;用户类型&#x27;);\n\n分别执行SQL语句\nUPDATE t_user_base_info set username = &#x27;张三&#x27; where id = &#x27;001&#x27;;加行锁，因为是根据主键更新。UPDATE t_user_base_info set username = &#x27;李四&#x27; where login_account = &#x27;admin&#x27;;行锁升级为表锁，因为login_account字段上面没有索引。\n\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 十六、InnoDB存储引擎","url":"/2023/09/07/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%8D%81%E5%85%AD%E3%80%81InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/","content":"一、逻辑存储结构\n表空间（idb文件），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。\n段分为数据段、索引段、回滚段，InnoDB是索引组织表，数据段就是B+树的叶子结点，索引段为B+树的非叶子结点。段用来管理多个区（Extent）。\n区，表空间的单元结构，每个区的大小为1M。默认情况下，InnoDB存储引擎页大小为16K，即一个区中有64个连续页。\n页，是InnoDB存储引擎磁盘管理的最小存储单元，每一个页的大小默认为16K。为了保证数据的连续性，InnoDB存储引擎每次都会申请4～5个区。\nRow 行，InnoDB存储引擎是按行存放数据的。\n​\tTrx_id：每次对某条记录修改时，都会把事物id赋给trx_id隐藏列。\n​\tRoll point：每次对某条记录修改时，都会把旧的数据写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到修改前的信息。\n\n\n二、架构下面为InnoDB的架构图，其中左侧为内存结构，右侧为磁盘结构，中间为后台线程。\n\n1、内存结构Buffer Pool：缓冲池为主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（如果缓冲池中没有则从磁盘加载数据并且缓存），然后再以一定的频率刷新到磁盘，从而减少磁盘IO，加快处理速度。\n缓冲池以Page为单位，底层采用链表数据结构管理Page。根据状态可以将Page分为三类：\n​\t1、free page：空闲page，未被使用。\n​\t2、clean page：被使用的page，数据未被修改。\n​\t3、dirty page：脏页，被使用的page，数据被修改过，页中的数据与磁盘中的数据不一致。\nChange Buffer：更改缓冲区（针对于非唯一的二级索引），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而是从数据更改存储在更改缓冲区ChangeBuffer Pool中，在未来数据被读取时，将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。\nChange Buffer的意义是什么？\n与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次操作都去操作磁盘，则会引起非常大的磁盘IO，有了Change Buffer之后，就可以在缓冲池中进行合并操作，减少磁盘IO。\nAdaptive hash index：自适应hash索引，用于优化对Buffer Pool数据的查询。InnoDB存储引擎会监控对表上各索引页的查询，如果观察到hash索引可以提升查询速度，则建立hash索引，称之为自适应hash索引。自适应hash索引无需人工干预，系统根据情况会自动生成。\n参数：adaptive_hash_index\nLog Buffer：日志缓冲区，用来保存要写入磁盘的log日志数据（包括redo log、undo log），默认大小为16M，日志缓冲区中的日志会定期刷新到磁盘中。如果需要更新、插入、删除许多行的事物，增大日志缓冲区的大小可以节省磁盘IO。\n参数：\ninnodb_log_buffer_size：缓冲区大小\nInnodb_flush_log_at_trx_commit：日志刷新到磁盘时机（1:日志在每次提交事物时写入磁盘文件；0:每秒将日志写入到磁盘文件一次；2:日志在每次提交事物后写入磁盘文件并且每秒刷新日志到磁盘文件）\n2、磁盘结构System Tablespace：系统表空间时更改缓冲区的存储区域。如果表是在系统表空间而不是每个表空间文件或者通用的表空间中创建的，他可能包含表和索引文件。（MySQL5.x版本还包括InnoDB数据字典和undo等）\n参数：innodb_data_file_path\nFile-pre-table Tablespace：每个表的文件表空间，包含单个InnoDB表的数据和索引，并存储在文件系统上的单个数据文件中。\n参数：innodb_file_pre_table\nGeneral Tablespace：通用表空间，需要通过CREATE TABLESPACE语法创建表空间，在创建表时可以指定该表空间。\n语法\nCREATE TABLESPACE xxx ADD DEFAULT &#x27;file_name&#x27; ENGINE = engine_name;\n\nCREATE TABLE xxx ... TABLESPACE tablespace_name;\n\nUndo Tablespace：撤销表空间，MySQl实例在初始化的时候会自动创建两个默认的undo表空间（初始大小16M），用于存储undo log。\nTemporary Tablespace：InnoDB使用回话临时表空间和全局临时表空间，存储用户创建的临时表等数据。\nDoublewrite Buffer File：双写缓冲区，InnoDB引擎将数据也从Buffer Pool刷新到磁盘前，先将数据页写入到双写缓冲区文件中，便于系统异常时恢复数据。\n相关文件：#ib_xxxxx_0.dblwr、#ib_xxxxx_1.dblwr\nRedo Log：重做日志，用来实现事物的持久性。改日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log），前者是在内存中，后者在磁盘中。当事物提交之后会把所有的修改信息都存储在该日志中，用于在刷新脏页到磁盘时发生错误后恢复数据使用。\n以循环方式写入重做日志文件，涉及两个文件：ib_logfile0、ib_logfile_1\n3、后台线程\nMaster Thread：核心后台进程，负责调度其他线程，还负责异步将缓冲池中的数据刷新到磁盘中，保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收。\n\nIO Thread：在InnoDB存储引擎中大量使用了AIO来处理IO请求，这样可以极大提高数据库的IO性能，而IO线程主页负责这些IO请求的回调。\n\n\n  执行命令show engine innodb status;可查看到相应的信息。\n  \n\n\n\n线程类型\n默认个数\n职责\n\n\n\nRead Thread\n4\n负责读操作\n\n\nWrite Thread\n4\n负责写操作\n\n\nLog Thread\n1\n负责将日志缓冲区刷新到磁盘\n\n\ninsert buffer thread\n1\n负责将写缓冲区内容刷新到磁盘\n\n\n\nPurge Thread：主要用于回收事物已经提交的undo log，在事物提交后，undo log可能就不用了，就用它来回收。\n\nPage Cleaner Thread：协助Master Thread刷新脏页到磁盘的线程，他可以减轻Master Thread的压力，减少阻塞。\n\n\n三、事物原理事物：是一组操作的集合，它是一个不可分割的工作单元，事物会把所有的操作视为一个整体一起向系统提交或者撤销操作请求，即这些操作要么全部成功，要么全部失败。\n特性：\n\n原子性（Atomicity）：事物是不可分割的最小单元，要么全部成功，要么全部失败。\n一致性（Consistency）：事物完成时，必须使所有的数据保持一致的状态。\n隔离性（Isolation）：数据库系统提供的隔离机制，保证事物在不受外部并发操作影响的独立环境下运行。\n持久性（Durability）：事物一旦提交或回滚，他对数据库中的数据的改变是永久的。\n\nredo log：重做日志，记录的是事物提交时数据页的物理修改，用来实现事物的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file），前者是在内存中，后者在磁盘上。当事物提交时会把所有的修改信息存储在该日志文件中，用于刷新脏页数据到磁盘时发生错误后进行数据恢复使用。\n\n客户端请求过来之后，首先去BufferPool中查找是否存在要操作的数据，如果不存在则从data文件中加载到BufferPool中然后操作，同时将操作记录到RedoLog Buffer中，RedoLog Buffer中的再写入到redo log file中，后台线程在刷新脏页数据到磁盘文件时如果出错可以借助redo log file进行恢复。\n为什么redo log buffer会直接写入磁盘而Buffer Pool时后台线程刷新到磁盘？因为redo log buffer写入到磁盘是顺序磁盘写入，效率要远高于Buffer Pool写入磁盘的随机磁盘写入。\nWAL(Write Ahead Log)预写日志，是数据库系统中常见的一种手段，用于保证数据操作的原子性和持久性。\nundo log：回滚日志，用于记录数据被修改前的信息，作用包含两个：提供回滚和MVCC（多版本并发控制）。\nundo log和redo log记录物理日志不一样，记录的是逻辑日志。可以认为当客户端执行一条delete语句时，它会记录一条相应的insert语句，当执行一条update语句时，它会记录一条反向的update语句。当rollback时，就可以从undo log中读取相应的记录进行回滚操作。\nundo log销毁：undo log在事物执行时产生，在事物提交时并不会立即删除，因为这些日志还可能用于MVCC。\nundo log存储：undo log采用段的方式管理和记录，存储在rollback segement回滚段中，内部包含1024个undo log segement。\n\nMySQL中如何保证事物的四大特性？\n​\t\t\tRedoLog保证了事物的持久性\n​\t\t\tUndoLog保证了事物的原子性\n​\t\t\tRedoLog+UndoLog保证了事物的一致性\n​\t\t\tMVCC+锁保证了事物的隔离型\n\n\n\n\n\n四、MVCC1、mvcc中的一些基本概念当前读：读取的是记录的最新版本，读取时还要保证其他并发事物不能修改当前记录，会对读取的记录进行加锁。对于我们的日常操作，如select … lock in share mode（共享锁）, select … for update、update、insert、delete（排它锁）都是一种当前读。\n\n同时开启两个事物A和B，事物A对表中的id&#x3D;1的记录进行修改后并未提交，事物B查询时为修改前的数据，事物A提交事物后事物B查询时还是修改前的数据，此时将事物B的查询语句后增加lock in share mode可读取到id&#x3D;1的最新数据。\n\n快照读：简单的select查询就是快照读，读取的是记录数据的可见版本，有可能是历史数据，不会加锁，是非阻塞读。\n\nRead Committed：每次select都生成一个快照读。\nRepeatable Read：开启事物后第一个select语句才是快照读的地方。\nSerializable：快照读会退化为当前读。\n\nMVCC：多版本并发控制。指的是维护数据库的多个版本，使得读写操作没有冲突，快照读为MySQL实现，MVCC提供了一个非阻塞读功能，MVCC的具体实现还的依赖于数据库中的三个隐式字段、undo log、readView。\n2、隐藏字段\n创建用户表user时包含了三个字段，但实际在数据库中是6（或者5个）个字段。\n\n\n\n隐藏字段\n含义\n\n\n\nDB_TRX_ID\n最近修改事物的ID，记录插入这条数据或者最后一次修改这条数据的事物ID\n\n\nDB_ROLL_PTR\n回滚指针，记录这条记录的上一个版本，用于配合undo log，指向上一个版本。\n\n\nDB_ROW_ID\n隐藏主键，如果表结构没有指定主键，将会生成该隐藏主键\n\n\n\n在表空间文件中，使用命令 idb2sdi xxx.idb 命令可查看到完整的表信息，其中就包含DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID这三个字段。\n\n3、undo log\n不同事物或相同事物对同一记录进行修改，会导致该纪录的undo log会生成一条记录版本链表，链表的头部是最新的旧记录，链表的尾部是最早的旧记录。\n4、readViewReadVIew（读视图）是快照读SQL执行时MVCC读取数据的依据，记录并且维护系统当前活跃的事物（未提交）ID。\nReadVIew中包含了四个核心字段\n\n\n\n字段\n含义\n\n\n\nm_ids\n当前活跃的事物ID集合\n\n\nmin_trx_id\n最小活跃事物ID\n\n\nmax_trx_id\n预分配事物ID，当前最大事物ID+1（因为事物ID是自增的）\n\n\ncreator_trx_id\nReadVIew创建者的事物ID\n\n\n\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 十四、SQL中的视图","url":"/2023/08/28/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%8D%81%E5%9B%9B%E3%80%81SQL%E4%B8%AD%E7%9A%84%E8%A7%86%E5%9B%BE/","content":"一、视图的基本介绍和语法定义视图(View): 是一种虚拟存在的表，视图中的数据并不是真实存在的，行和列数据来自定义视图的查询中使用的表，并且是在使用时图时动态生成。通俗讲，视图只保存了查询数据的SQL，不保存查询结果，所以我们创建视图的时候主要工作就落在了创建这条SQL查询语句上。\n语法\n创建视图CRAETE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION];\n查看创建视图语句SHOW CREATE VIEW 视图名称;查看视图数据SELECT 字段列表 FROM 视图名称 [WHERE ...];\n修改视图方式一：CRAETE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION];视图二：ALTER 视图名称[(列名列表)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION];\n删除视图DROP VIEW [IF EXISTS] 视图名称, [视图名称,]...\n\n\n二、视图中的检查选项当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查每个正在更改的行，例如插入，更新，删除，已使其符合视图的定义。MySQl允许基于另一个视图创建视图，它会依赖检查视图中的规则以保持一致性。WITH CASCADED CHECK OPTION   检查选项会传递需要满足当前视图的条件。并且对于所有底部视图的条件，也需要一并满足，哪怕底部视图没有定义with check option语句。\n\n不指定约束类型时，默认为cascaded约束，with check option &#x3D; with cascaded check option。\n\n创建视图 \ncreate or replace view stu_v_1 as select id, name from student where id &gt;= 10;\n执行以下插入语句均不会报错，因为当前视图没有检查选项。\ninsert into stu_v_1 values(8, &#x27;tom&#x27;);insert into stu_v_1 values(18, &#x27;jerry&#x27;);\n重新创建视图，指定约束条件\ncreate or replcae view stu_v_2 as select id, name from stu_v_1 where id &lt;= 20 with cascaded check option;\n再次执行以下插入语句，第一条语句会报错，因为stu_v_1要求id&gt;&#x3D;10,但是第二条语句不会报错。\ninsert into stu_v_2 values(8, &#x27;tom&#x27;);insert into stu_v_2 values(18, &#x27;jerry&#x27;);\nWITH LOCAL CHECK OPTION    检查选项不会传递需要满足当前视图的条件。对于底部视图，也是先看是否有指定的with check option语句，有的话对应处理，无则不需要满足底部视图的条件。创建视图 \ncreate or replcae view stu_v_3 as select id, name from student where id &gt;= 10;\n执行以下插入语句均不会报错，因为当前视图没有检查选项。\ninsert into stu_v_1 values(8, &#x27;tom&#x27;);insert into stu_v_1 values(18, &#x27;jerry&#x27;);\n重新创建视图，指定约束条件\ncreate or replcae view stu_v_4 as select id, name from stu_v_3 where id &lt;= 20 with local check option;\n再次执行以下插入语句，都不会报错，因为stu_v_3上没有check option校验，它只会校验stu_v_4上的约束满足即可。\ninsert into stu_v_2 values(8, &#x27;tom&#x27;);insert into stu_v_2 values(18, &#x27;jerry&#x27;);\n\n\n三、视图的更新和作用视图的更新要使视图可以更新，视图中的行与基础表中的行之间必须存在一一对应的关系。如果视图包含以下任意一项，则该视图不可更新：    1、聚合函数或者窗口函数（SUM(), MIN(), MAX(), COUNT()等）    2、DISTINCT    3、GROUP BY    4、HAVING    5、UNION或者UNION ALL视图的作用简单：视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些经常被使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次都指定全部的条件。安全：数据库可以授权，但是不能授权到数据库特定的行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据。数据独立：视图可以帮助用户屏蔽真实表结构变化带来的影响。\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 四、SQL语言中DQL语句的语法","url":"/2023/07/28/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%9B%9B%E3%80%81SQL%E8%AF%AD%E8%A8%80%E4%B8%ADDQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%AF%AD%E6%B3%95/","content":"DQL：数据查询语言，用来查询数据库中表里面的数据。\nDQL语法‍‍‍\nSELECT 字段列表 FROM 表名 WHERE 条件 GROUP BY 分组 HAVING 分组后的条件列表 ORDER BY 排序字段列表 LIMIT 分页参数;\n\n数据查询语言的分类：\n&emsp;&emsp;&emsp;&emsp;基本查询‍‍\n&emsp;&emsp;&emsp;&emsp;条件查询（WHERE）\n&emsp;&emsp;&emsp;&emsp;聚合查询（COUNT、MAX、MIN、AVG、SUM）\n&emsp;&emsp;&emsp;&emsp;分组查询（GROUP BY）‍‍‍‍‍\n&emsp;&emsp;&emsp;&emsp;排序查询（ORDER BY）\n&emsp;&emsp;&emsp;&emsp;分页查询（LIMIT）\n\n\n一、DQL的基础查询1、查询返回多个字段\nSELECT 字段1, 字段2, 字段n FROM 表名;SELECT * FROM 表名;\n\nselect * 可读性以及效率偏低，推荐 select 字段 的方式。\n2、设置别名\nSELECT 字段1 AS [别名1], 字段2 AS [别名2], ... 字段n AS [别名n] FROM 表名;\n\n3、去除重复记录\nSELECT DISTINCT 字段名 FROM 表名；\n\n\n\n二、DQL语句的条件查询‍‍\n\n\n比较运算符\n功能\n\n\n\n&gt;, &gt;&#x3D;\n大于，大于等于\n\n\n&lt;, &lt;&#x3D;\n小于，小于等于\n\n\n&#x3D;\n等于\n\n\n&lt;&gt;, !&#x3D;\n不等于\n\n\nBETWEEN…AND…\n在某个范围内（含最大值和最小值）\n\n\nIN(…)\n在IN之后的列表中\n\n\nLIKE 占位符\n模糊匹配\n\n\nIS NULL\n是NULL\n\n\n\n\n\n\n\n逻辑运算符\n功能\n\n\n\nAND 或 &amp;&amp;\n并且（多个条件同时成立）\n\n\nOR 或 ||\n或者（多个条件满足一个）\n\n\nNOT 或 ！\n非，不是\n\n\n1、查询年龄小于18的员工\nSELECT * FROM 表名 WHERE age &lt; 18;\n\n2、查询年龄等于20的员工‍\nSELECT * FROM 表名 WHERE age = 20;\n\n2、查询年龄不等于20的员工\nSELECT * FROM 表名 WHERE age != 20;SELECT * FROM 表名 WHERE age &lt;&gt; 20;\n\n3、查询没有年龄的员工信息  \nSELECT * FROM 表名 WHERE age is null;\n\n4、查询有年龄的员工信息  \nSELECT * FROM 表名 WHERE age is not null;\n\n6、查询年龄在20到30的员工信息\nSELECT * FROM 表名 WHERE age between 20 and 30;SELECT * FROM 表名 WHERE age &gt;= 20 and and &lt;= 30;\n\n7、查询年龄为20且性别为女的员工信息‍\nSELECT * FROM 表名 WHERE age = 20 and sex = &#x27;女&#x27;;\n\n8、查询年龄为20或者30或者40的员工信息\nSELECT * FROM 表名 WHERE age = 20 or age = 30 or age = 40;SELECT * FROM 表名 WHERE age in (20, 30, 40);\n\n9、查询姓名为两个字的员工(一个下划线代表一个字符)\nSELECT * FROM 表名 WHERE name like &#x27;__&#x27;;\n\n10、查询身份证号最后一位是X的员工信息‍‍‍‍\nSELECT * FROM 表名 WHERE id_card like &#x27;%X&#x27;;\n\n  \n\n三、DQL语句的聚合函数‍‍‍‍‍‍聚合函数作用：将一列数据作为一个整体进行纵向计算。\n注意：所有的null值不进行聚合函数计算。\n1、统计员工数量\nSELECT count(*) FROM 表名;SELECT count(字段名) FROM 表名;\n\n2、统计平均值\nSELECT avg(字段名) FROM 表名;\n\n3、查询最大值  \nSELECT max(字段名) FROM 表名;\n\n4、查询最小值‍\nSELECT min(字段名) FROM 表名;\n\n5、查询某个字段的和\nSELECT sum(字段名)  FROM 表名;\n\n  \n\n四、DQL语句的分组查询‍‍‍‍语法：SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY [HAVING 分组后的过滤条件]‍‍‍‍‍\n注意：\n&emsp;&emsp;&emsp;&emsp;1、分组查询的顺序为where -&gt; 聚合函数 -&gt; having‍‍‍‍‍‍‍‍‍‍‍‍\n&emsp;&emsp;&emsp;&emsp;2、分组之后查询的字段一般为聚合函数和分组字段，查询其他字段无意义。\n&emsp;&emsp;&emsp;&emsp;1、根据性别分组，查询男女员工的数量\nSELECT count(*) FROM 表名 GROUP BY gender;\n\n2、根据性别分组，查询男女员工的平均年龄  \nSELECT avg(age) FROM 表名 GROUP BY gender;\n\n3、查询年龄小于45的员工并且根据工作地址分组，获取员工数量大于3的工作地址\nSELECT count(*) as address_count FROM 表名 WHERE age &lt; 45 GROUP BY work_address HAVING address_count &gt;= 3;\n\n五、DQL语句的排序查询SQL语句中支持多个字段排序，排序方式有两种：ASC代表升序(默认值)，DESC代表降序。‍‍\n1、根据年龄对员工进行升序排列\nSELECT 字段名 FROM 表名 ORDER BY age ASC;\n\n2、根据入职时间进行降序排列  \nSELECT 字段名 FROM 表名 ORDER BY entry_date DESC;\n\n3、根据年龄对员工进行升序排序，年龄相同根据入职时间将序排列‍‍\nSELECT 字段名 FROM 表名 ORDER BY age ASC, entry_date DESC;\n\n  \n\n六、DQL语句的分页查询语法：SELECT 字段名 FROM 表名 LIMIT 起始索引,查询记录数;\n注意：LIMIT为MySQL的方言，不同数据库分页有不同的实现。‍‍\n1、查询第一页的员工数据，每页展示10条\nSELECT * FROM LIMIT 0,10;\n\n2、查询第二页的员工数据，每页展示10条  \nSELECT * FROM LIMIT 10,10;\n\n  \n\n七、DQL语句的执行顺序‍‍‍‍FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT\n","tags":["数据库","MySQL"]},{"title":"工作笔记 ｜ 一个简单的在linux系统中启动jar包的命令","url":"/2023/08/29/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%20%EF%BD%9C%20%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%90%AF%E5%8A%A8jar%E5%8C%85%E7%9A%84%E5%91%BD%E4%BB%A4/","content":"\n当有多个项目时，挨个重启总是感觉很麻烦，所以下面这个脚本诞生了，直接替换app列表中的参数为启动的jar包名即可挨个启动项目。启动前会判断当前是否存在运行该jar包的进程，存在的话先杀死进程，再执行启动命令。日志输出可以提出来写一个公共方法，启动模版也是（后面有时间的话可以考虑可以改一下）。\n\n#!/bin/bashsource ~/.bash_profilesource /etc/profileecho &quot;#####################  &quot;`date &#x27;+%Y-%m-%d %H:%M&#x27;`&quot; ########################&quot; &gt;&gt; run.log###JVM参数JAVA_OPTIONS=&quot;-Xms1024m -Xmx1024m -Xmn256m -Xss256k -XX:MetaspaceSize=64m -XX:MaxMetaspaceSize=64m&quot;### JMX参数JMX_OPTIONS=&quot;-Djava.rmi.server.hostname=127.0.0.1 -Dcom.sun.management.jmxremote.port=8098 -Dcom.sun.management.jmxremote.rmi.port=8098 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false&quot;# 服务列表app=(linze_healthcheck_java_pc-0.0.1-SNAPSHOT)for i in $&#123;app[*]&#125;;do        # 停止旧项目    ps -ef | grep $i.jar | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill -9    echo &#x27;停止项目完成!!!&#x27;\tpid=`ps -ef | grep $i.jar| grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`\t# 判断当前服务是否启动\tif [ &quot;$pid&quot; != &quot;&quot; ]; then\t\techo &#x27;当前服务[ &#x27;$i&#x27; ]已经是运行状态,端口号：&#x27;$pid &gt;&gt; run.log\t\t# 杀死进程重新启动\t\techo &#x27;杀死旧进程:&#x27;$pid&#x27;, 准备重新启动&#x27; &gt;&gt; run.log\t\tkill -9 $pid\t\t# 休息3s\t\tsleep 3\t\tfor name in `find . -name $i.jar`;do\t\t\tnohup java -jar $JAVA_OPTIONS $JMX_OPTIONS $name &gt; /dev/null 2&gt;&amp;1 &amp;\t\t\tsleep 3\t\t\tppid=`ps -ef | grep $i.jar| grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`\t\t\tif [ &quot;$ppid&quot; != &quot;&quot; ]; then\t\t\t\techo &#x27;服务[ &#x27;$i&#x27; ]重启完成！&#x27; &gt;&gt; run.log\t\t\telse\t\t\t\techo &#x27;服务[ &#x27;$i&#x27; ]重启失败！&#x27; &gt;&gt; run.log\t\t\tfi\t\tdone\telse\t\tfor name in `find . -name $i.jar`;do\t\t\techo &#x27;当前启动服务[ &#x27;$i&#x27; ], jar位置:&#x27;$name &gt;&gt; run.log\t\t\tnohup java -jar $JAVA_OPTIONS $JMX_OPTIONS $name &gt; /dev/null 2&gt;&amp;1 &amp;\t\t\tsleep 3\t\t\tppid=`ps -ef | grep $i.jar| grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`\t\t\tif [ &quot;$ppid&quot; != &quot;&quot; ]; then\t\t        echo &#x27;服务[ &#x27;$i&#x27; ]启动完成！&#x27; &gt;&gt; run.log\t\t\telse\t\t\t\techo &#x27;服务[ &#x27;$i&#x27; ]启动失败！&#x27; &gt;&gt; run.log\t\t\tfi\t\tdone\tfidone","tags":["Shell"]},{"title":"面试题库 | Java基础知识","url":"/2023/09/27/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93%20%7C%20Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"\n所有的面试题目全部整理自网络，若有错误可联系作者改正。题目信息和Java面试题库Pro小程序保持一致，小程序方便移动端刷题，该网页方便在PC刷题。所有的建议和意见均可通过小程序Java面试题库Pro找到客服反馈或者添加作者的联系方式。\n\n1、什么是跨平台性？原理是什么所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。\n2、什么是字节码？采用字节码的最大好处是什么Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。\n3、采用字节码的好处Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。\n4、OracleJDK 和 OpenJDK 的对比1、Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；2、OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；3、Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业&#x2F;商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；4、在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；5、Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；6、Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。\n5、什么是面向对象面向对象程序设计是以建立模型体现出来的抽象思维过程和面向对象的方法。我们可以将某个事物抽象出来，赋予它自己的特征，并且可以针对这个事物进行相应的操作，以及规定与其他对象之间的关系。可以降低代码的耦合度，使程序更加灵活。\n6、多态的实现需要哪些条件Java实现多态有三个必要条件：继承、重写、向上转型。继承：在多态中必须存在有继承关系的子类和父类。重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。向上转型：在多态中需要将子类的引用赋给父类对象。\n7、面向对象五大基本原则是什么单一职责原则SRP(Single Responsibility Principle)：类的功能要单一，不能包罗万象，跟杂货铺似的。开放封闭原则OCP(Open－Close Principle)：一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。里式替换原则LSP(the Liskov Substitution Principle LSP)：子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~依赖倒置原则DIP(the Dependency Inversion Principle DIP)：高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。接口分离原则ISP(the Interface Segregation Principle ISP)：设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。\n8、什么是值传递和引用传递值传递：是对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。引用传递：一般是对于对象型变量而言的，传递的是该对象地址的一个副本，但是该副本和原对象指向的是内存中的同一个地址，改变副本会影响对象。\n9、抽象类和接口的区别抽象类的特点：    &nbsp;&nbsp;&nbsp;&nbsp;抽象类使用 abstract 关键字声明。    &nbsp;&nbsp;&nbsp;&nbsp;抽象类中可以包含普通方法和抽象方法，抽象方法不能有具体的代码实现。    &nbsp;&nbsp;&nbsp;&nbsp;抽象类需要使用 extends 关键字实现继承。    &nbsp;&nbsp;&nbsp;&nbsp;抽象类不能直接实例化。    &nbsp;&nbsp;&nbsp;&nbsp;抽象类中属性控制符无限制，可以定义 private 类型的属性。\n接口的特点：    &nbsp;&nbsp;&nbsp;&nbsp;JDK 8 中接口可以定义 static 和 default 方法，并且这两种方法可以包含具体的代码实现。    &nbsp;&nbsp;&nbsp;&nbsp;实现接口要使用 implements 关键字。    &nbsp;&nbsp;&nbsp;&nbsp;接口不能直接实例化。    &nbsp;&nbsp;&nbsp;&nbsp;接口中定义的变量默认为 public static final 类型。    &nbsp;&nbsp;&nbsp;&nbsp;子类可以不重写接口中的 static 和 default 方法，不重写的情况下，默认调用的是接口的方法实现。\n抽象类和接口的区别：    &nbsp;&nbsp;&nbsp;&nbsp;定义的关键字不同。    &nbsp;&nbsp;&nbsp;&nbsp;子类继承或实现关键字不同。    &nbsp;&nbsp;&nbsp;&nbsp;类型扩展不同：抽象类是单继承，而接口是多继承。    &nbsp;&nbsp;&nbsp;&nbsp;方法访问控制符：抽象类无限制，只是抽象类中的抽象方法不能被 private 修饰；而接口有限制，接口默认的是 public 控制符。    &nbsp;&nbsp;&nbsp;&nbsp;属性方法控制符：抽象类无限制，而接口有限制，接口默认的是 public 控制符。    &nbsp;&nbsp;&nbsp;&nbsp;方法实现不同：抽象类中的普通方法必须有实现，抽象方法必须没有实现；而接口中普通方法不能有实现，但在 JDK 8 中的 static 和 defualt 方法必须有实现。    &nbsp;&nbsp;&nbsp;&nbsp;静态代码块的使用不同：抽象类可以有静态代码块，而接口不能有。\n10、什么是不可变对象不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。\n11、静态变量和实例变量的区别1、存储区域不同：静态变量存储在方法区，实例变量存储在堆中，会被垃圾回收释放。2、关联不同：静态变量与类相关，实例变量与对象相关。3、生命周期不同：静态变量在类启动时就分配内存，实例变量在被对象调用后才分配内存，调用结束时内存释放。\n12、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java 5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型。从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。\n13、用最有效率的方法计算 2 乘以 82 &lt;&lt; 3  （左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。\n14、short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗对于 short s1 &#x3D; 1; s1 &#x3D; s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。而 short s1 &#x3D; 1; s1 +&#x3D; 1;可以正确编译，因为 s1+&#x3D; 1 相当于 s1 &#x3D; (short(s1 + 1)) 其中有隐含的强制类型转换。\n15、final有哪些用法1.被final修饰的类不可以被继承2.被final修饰的方法不可以被重写3.被final修饰的变量不可以被改变。如果修饰引用，那么表示引用不可变，引用指向的内容可变。4.被final修饰的方法，JVM会尝试将其内联，以提高运行效率5.被final修饰的常量，在编译阶段会存入常量池中。回答出编译器对final域要遵守的两个重排序规则更好：1.在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序。2.初次读一个包含final域的对象的引用，与随后初次读这个final域,这两个操作之间不能重排序。\n16、final finally finalize区别final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。\n17、static存在的主要意义static的主要意义是在于创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。\n18、a&#x3D;&#x3D;b与a.equals(b)有什么区别如果 a 和 b 都是对象，则 a&#x3D;&#x3D;b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true。a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。\n19、什么是内部类，内部类的分类有哪些在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致。内部类可以分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。\n20、内部类的优点一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！内部类不为同一包的其他类所见，具有很好的封装性；内部类有效实现了“多重继承”，优化 java 单继承的缺陷。匿名内部类可以很方便的定义回调。\n21、BIO,NIO,AIO 有什么区别BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。\n22、什么是反射机制简单说，反射机制指得是程序在运行时能够获取自身的信息。在java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息。JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。\nClass c = Teacher.class;    //定义一个类对象cObject obj = c.newInstance();    //通过反射获得一个实例//调用set方法給属性赋值Method m1=c.getMethod(&quot;setName&quot;, String.class);    //获得方法m1.invoke(obj,name);    //调用方法\n\n23、反射机制的应用场景有哪些反射是框架设计的灵魂，在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码。动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。举例：&nbsp;&nbsp;(1)、我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；&nbsp;&nbsp;(2)、Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：    &nbsp;&nbsp;&nbsp;&nbsp;1) 将程序内所有 XML 或 Properties 配置文件加载入内存中;    &nbsp;&nbsp;&nbsp;&nbsp;2) Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息;    &nbsp;&nbsp;&nbsp;&nbsp;3) 使用反射机制，根据这个字符串获得某个类的Class实例;    &nbsp;&nbsp;&nbsp;&nbsp;4) 动态配置实例的属性\n24、Java获取反射的三种方法1.通过new对象实现反射机制2.通过路径实现反射机制3.通过类名实现反射机制\npublic class Student &#123;    private int id;    String name;    protected boolean sex;    public float score;&#125;public class Get &#123;    //获取反射机制三种方式public static void main(String[] args) throws ClassNotFoundException &#123;        //方式一(通过建立对象)        Student stu = new Student();        Class classobj1 = stu.getClass();        System.out.println(classobj1.getName());        //方式二（所在通过路径-相对路径）Class classobj2 = Class.forName(&quot;fanshe.Student&quot;);        System.out.println(classobj2.getName());        //方式三（通过类名）Class classobj3 = Student.class;        System.out.println(classobj3.getName());    &#125;&#125;\n\n25、反射中，Class.forName 和 ClassLoader 区别java中class.forName()和classLoader都可用来对类进行加载。class.forName()前者除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。而classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。\n26、什么是动态代理代理类在程序运行时创建的代理方式被成为 动态代理。 也就是说，这种情况下，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。\n27、Java动态代理的两种实现方法jdk动态代理是由java内部的反射机制来实现的，cglib动态代理底层则是借助asm来实现的。jdk动态代理是jdk原生就支持的一种代理方式，它的实现原理，就是通过让target类和代理类实现同一接口，代理类持有target对象，来达到方法拦截的作用，这样通过接口的方式有两个弊端，一个是必须保证target类有接口，第二个是如果想要对target类的方法进行代理拦截，那么就要保证这些方法都要在接口中声明，实现上略微有点限制。Cglib是一个优秀的动态代理框架，它的底层使用ASM在内存中动态的生成被代理类的子类，使用CGLIB即使代理类没有实现任何接口也可以实现动态代理功能。CGLIB具有简单易用，它的运行速度要远远快于JDK的Proxy动态代理：\n28、什么是 Java 序列化序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。反序列化的过程，则是和序列化相反的过程。另外，我们不能将序列化局限在 Java 对象转换成二进制数组，例如说，我们将一个 Java 对象，转换成 JSON 字符串，或者 XML 字符串，这也可以理解为是序列化。\n29、Java 序列化中，如果有些字段不想进行序列化怎么办对于不想进行序列化的变量，使用 transient 关键字修饰，当对象被序列化时，阻止实例中那些用此关键字修饰的的变量序列化。当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复，transient 只能修饰变量，不能修饰类和方法。\n30、String有哪些特性不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。\n31、String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗不一样，因为内存的分配方式不一样。String str&#x3D;”i”的方式，java 虚拟机会将其分配到常量池中；而 String str&#x3D;new String(“i”) 则会被分到堆内存中。\n32、String s &#x3D; new String(“xyz”);创建了几个字符串对象如果字符串常量池中存在 “xyz”，则只会创建一个对象，即堆中 new 出来的新对象。如果字符串常量池中不存在 “xyz”，则会创建两个对象，一个是字符串常量池的 “xyz”，一个是用 new 创建在堆上的对象。\n33、在使用 HashMap 的时候，用 String 做 key 有什么好处HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。\n34、String、StringBuffer、StringBuilder区别String 是字符串常量，final 修饰；StringBuffer 字符串变量(线程安全)；StringBuilder 字符串变量(线程不安全)；String和StringBuffer1、String和StringBuffer 主要区别是性能：String 是不可变对象，每次对 String 类型进行操作都等同于产生了一个新的 String 对象，然后指向新的 String 对象。所以尽量不在对 String 进行大量的拼接操作，否则会产生很多临时对象，导致 GC 开始工作，影响系统性能。2、StringBuffer 是对对象本身操作，而不是产生新的对象，因此在有大量拼接的情况下，我们建议使用 StringBuffer。3、VM会对String拼接做一定的优化：String s&#x3D;“This is only ”+”simple”+”test” 会被虚拟机直接优化成 String s&#x3D;“This is only simple test”，此时就不存在拼接过程。StringBuffer 和 StringBuilderStringBuffer 是线程安全的可变字符串，其内部实现是可变数组。StringBuilder 是 jdk 1.5 新增的，其功能和 StringBuffer 类似，但是非线程安全。因此，在没有多线程问题的前提下，使用 StringBuilder 会取得更好的性能。\n35、Overload和Override的区别方法重写Overriding和方法重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloading的方法是可以改变返回值的类型。\n36、Java有哪些数据类型基本数据类型&nbsp;&nbsp;&nbsp;&nbsp;整数类型(byte，short，int，long)&nbsp;&nbsp;&nbsp;&nbsp;浮点类型(float，double)&nbsp;&nbsp;&nbsp;&nbsp;字符型(char)&nbsp;&nbsp;&nbsp;&nbsp;布尔型(boolean)引用数据类型&nbsp;&nbsp;&nbsp;&nbsp;类(class)&nbsp;&nbsp;&nbsp;&nbsp;接口(interface)&nbsp;&nbsp;&nbsp;&nbsp;数组([])\n37、switch是否能作用在byte上，是否能作用在long上，是否能作用在String上在 Java5 以前，switch(expr) 表达式中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型。从 Java7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。\n38、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11，四舍五入的原理是在参数上加0.5然后进行下取整。\n39、表达式 float f &#x3D; 3.4 是否正确不正确，3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换 float f &#x3D; (float) 3.4 或者写成 float f &#x3D; 3.4F。\n40、访问修饰符 public、private、protected以及不写（默认）时的区别private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见。使用对象：类、接口、变量、方法。protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。public : 对所有类可见。使用对象：类、接口、变量、方法。\n41、运算符&amp;和&amp;&amp;的区别&amp;运算符有两种用法：&nbsp;&nbsp;(1) 按位与&nbsp;&nbsp;(2) 逻辑与&amp;&amp;运算符是短路与运算，逻辑与跟短路与的差别是非常巨大的，二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。\n42、3*0.1 &#x3D;&#x3D; 0.3 返回值是什么返回false，因为有些浮点数不能完全精确的表示出来。\n43、a &#x3D; a+b 与 a +&#x3D; b 有什么区别吗+&#x3D; 操作符会进行隐式自动类型转换，此处 a +&#x3D;b 隐式的将加操作的结果类型强制转换为持有结果的类型，而 a &#x3D; a+b 则不会自动进行类型转换。\n44、如何将byte转为String可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。\n45、可以将 int 强转为 byte 类型吗？会产生什么问题可以做强制转换，但是Java中int是32位的而byte是8位的，所以如果进行强制转换，int类型的高24位将会被丢弃，byte 类型的范围是从-128到127。\n46、Java 有没有 gotogoto 是 Java 中的保留字，在目前版本的 Java 中没有使用。\n47、final 关键字有什么用用于修饰类、属性和方法&nbsp;&nbsp;&nbsp;&nbsp;被final修饰的类不可以被继承&nbsp;&nbsp;&nbsp;&nbsp;被final修饰的方法不可以被重写&nbsp;&nbsp;&nbsp;&nbsp;被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的。\n48、this 关键字的用法this 是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。\nthis 的用法大体可以分为3种：&nbsp;&nbsp;1.普通的直接引用，this相当于是指向当前对象本身。&nbsp;&nbsp;2.形参与成员名字重名，用 this 来区分:\npublic Person(String name, int age) &#123;    this.name = name;    this.age = age;&#125;\n&nbsp;&nbsp;3.引用本类的构造函数:\nclass Person&#123;    private String name;    private int age;        public Person() &#123;    &#125;     public Person(String name) &#123;        this.name = name;    &#125;    public Person(String name, int age) &#123;        this(name);        this.age = age;    &#125;&#125;\n\n49、super 关键字的用法super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。super有三种用法:&nbsp;&nbsp;1.普通的直接引用，与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。&nbsp;&nbsp;2.子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分：\nclass Person&#123;    protected String name;     public Person(String name) &#123;        this.name = name;    &#125;&#125; class Student extends Person&#123;    private String name;     public Student(String name, String name1) &#123;        super(name);        this.name = name1;    &#125;     public void getInfo()&#123;        System.out.println(this.name);      //Child        System.out.println(super.name);     //Father    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;       Student s1 = new Student(&quot;Father&quot;,&quot;Child&quot;);       s1.getInfo();     &#125;&#125;\n&nbsp;&nbsp;3.引用父类构造函数&nbsp;&nbsp;&nbsp;&nbsp;super（参数）: 调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。&nbsp;&nbsp;&nbsp;&nbsp;this（参数）: 调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。\n50、this 与 super 的区别super：它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量、super.成员函数名（实参）。this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）。super() 和 this() 类似，区别是 super() 在子类中调用父类的构造方法，this() 在本类内调用本类的其它构造方法。super() 和 this() 均需放在构造方法内第一行。可以用this调用一个构造器，但不能调用两个。this 和 super 不能同时出现在一个构造函数里面，因为 this 必然会调用其它的构造函数，其它的构造函数必然也会有 super 语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。this() 和 super() 都指的是对象，所以均不可以在 static 环境中使用。包括：static变量、static方法、static语句块。从本质上讲，this是一个指向本对象的指针，然而super是一个Java关键字。\n51、static的特点1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。\n52、break 、continue、return 的区别及作用break 跳出当前循环，不再执行循环(结束当前的循环体)continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)\n53、在 Java 中，如何跳出当前的多重嵌套循环在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：\npublic static void main(String[] args) &#123;  ok:  for (int i = 0; i &lt; 10; i++) &#123;    for (int j = 0; j &lt; 10; j++) &#123;      System.out.println(&quot;i=&quot; + i + &quot;,j=&quot; + j);      if (j == 5) &#123;        break ok;      &#125;    &#125;  &#125;&#125;\n\n54、抽象类和接口的对比抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。从设计层面来说，抽象类是对类的抽象，是一种模板设计；接口是行为的抽象，是一种行为的规范。\n相同点&nbsp;&nbsp;接口和抽象类都不能实例化&nbsp;&nbsp;都位于继承的顶端，用于被其他实现或继承&nbsp;&nbsp;都包含抽象方法，其子类都必须覆写这些抽象方法\n不同点暂时省略。。。\n接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：&nbsp;&nbsp;行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。&nbsp;&nbsp;选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。\n55、普通类和抽象类有哪些区别普通类不能包含抽象方法，抽象类可以包含抽象方法。抽象类不能直接实例化，普通类可以直接实例化。\n56、抽象类能使用 final 修饰吗不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类。\n57、Java支持多继承么Java 中类不支持多继承，只支持单继承（即一个类只有一个父类）。但是 Java 中的接口支持多继承，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。\n58、成员变量与局部变量的区别有哪些定义位置不同&nbsp;&nbsp;成员变量：定义在方法外部，类的内部。&nbsp;&nbsp;局部变量：定义在方法中。作用域&nbsp;&nbsp;成员变量：针对整个类有效。&nbsp;&nbsp;局部变量：只在某个范围内有效。(一般指的就是方法，离他最近最近的{}内)存储位置&nbsp;&nbsp;成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。&nbsp;&nbsp;局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。生命周期&nbsp;&nbsp;成员变量：随着对象的创建而存在，随着对象的消失而消失。&nbsp;&nbsp;局部变量：当方法调用完，或者语句结束后，就自动释放。初始值&nbsp;&nbsp;成员变量：有默认初始值。&nbsp;&nbsp;局部变量：没有默认初始值，使用前必须赋值。\n59、为什么在Java中定义一个不做事且没有参数的构造方法Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行，解决办法是在父类里加上一个不做事且没有参数的构造方法。\n60、在调用子类构造方法之前会先调用父类没有参数的构造方法的其目是什么帮助子类做一些初始化工作。\n61、一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗主要作用是完成对类对象的初始化工作，没有声明构造方法程序可以执行，因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。\n62、静态变量和实例变量区别静态变量： 静态变量不属于任何实例对象，是属于类的，所以在内存中只会有一份，在类的加载过程中，JVM 只为静态变量分配一次内存空间。实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。\n63、静态方法和实例方法有何不同调用方式：在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只能使用”对象名.方法名”的方式。也就是说，调用静态方法可以无需创建对象。访问对象和方法：静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。\n64、什么是内部类？内部类的分类有哪些在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致。内部类可以分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。\n65、equals() 和 hashcode() 的关系hashCode() 是 Object 类的一个方法，返回一个哈希值。如果两个对象根据 equal() 方法比较相等，那么调用这两个对象的 hashCode() 方法必须产生相同的哈希值。如果两个对象根据 eqaul() 方法比较不相等，那么产生的哈希值不一定相等(会存在相等的情况)。\n66、hashCode() 方法有什么用将对象放入到集合中时，首先判断要放入对象的 hashcode 是否已经在集合中存在，不存在则直接放入集合。如果 hashcode 相等，然后通过 equal() 方法判断要放入对象与集合中的任意对象是否相等：如果 equal() 判断不相等，直接将该元素放入集合中，否则不放入。\n67、有没有可能两个不相等的对象有相同的hashcode有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突，如果两个对象相等，必须有相同的hashcode 值，反之不成立。\n68、a &#x3D;&#x3D; b 与 a.equals(b) 有什么区别如果 a 和 b 都是对象，则 a&#x3D;&#x3D;b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较，例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。基本类型比较用，比较的是他们的值。默认下，对象用比较时，比较的是内存地址，如果需要比较对象内容，需要重写equal方法。\n69、hashCode() 与 equals() 的相关规定如果两个对象相等，则hashcode一定也是相同的。两个对象相等，对两个对象分别调用equals方法都返回true。两个对象有相同的hashcode值，它们也不一定是相等的。hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。\n70、对象的相等与指向他们的引用相等，两者有什么不同对象相等比的是内存中存放的内容是否相等引用相等比较的是他们指向的内存地址是否相等\n71、注解原理是什么注解本质是一个继承了 Annotation 的特殊接口，其具体实现类是 Java 运行时生成的动态代理类。我们通过反射获取注解时，返回的是 Java 运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用 AnnotationInvocationHandler 的 invoke 方法，该方法会从 memberValues 这个 Map 中索引出对应的值，而 memberValues 的来源是 Java 常量池。\n","tags":["面试题","Java"]}]